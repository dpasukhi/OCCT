// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: curves2d.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>

#ifndef CAPNP_VERSION
#error "CAPNP_VERSION is not defined, is capnp/generated-header-support.h missing?"
#elif CAPNP_VERSION != 1002000
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif

#include "ode.capnp.h"

CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(90fbe3f5bc3c522a);
CAPNP_DECLARE_SCHEMA(afcf274108129c95);
CAPNP_DECLARE_SCHEMA(d652a168cbb438d9);
CAPNP_DECLARE_SCHEMA(a7db41f5d86a713b);
CAPNP_DECLARE_SCHEMA(ed759611969b5174);
CAPNP_DECLARE_SCHEMA(bb80d5283f5f03d8);
CAPNP_DECLARE_SCHEMA(fef7bbccba059ea2);
CAPNP_DECLARE_SCHEMA(a8075b7884f8b62a);
CAPNP_DECLARE_SCHEMA(b9abd33ada189878);
CAPNP_DECLARE_SCHEMA(9f2737113f4e5d41);
CAPNP_DECLARE_SCHEMA(e0ef9ef5efeaa0ec);

}  // namespace schemas
}  // namespace capnp


struct Curve2d {
  Curve2d() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    LINE,
    CIRCLE,
    ELLIPSE,
    HYPERBOLA,
    PARABOLA,
    BEZIER_CURVE,
    BSPLINE_CURVE,
    TRIMMED_CURVE,
    OFFSET_CURVE,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(90fbe3f5bc3c522a, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Line2d {
  Line2d() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(afcf274108129c95, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Circle2d {
  Circle2d() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d652a168cbb438d9, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Ellipse2d {
  Ellipse2d() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a7db41f5d86a713b, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Hyperbola2d {
  Hyperbola2d() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ed759611969b5174, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Parabola2d {
  Parabola2d() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bb80d5283f5f03d8, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct BezierCurve2d {
  BezierCurve2d() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fef7bbccba059ea2, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct BSplineCurve2d {
  BSplineCurve2d() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a8075b7884f8b62a, 1, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TrimmedCurve2d {
  TrimmedCurve2d() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b9abd33ada189878, 3, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct OffsetCurve2d {
  OffsetCurve2d() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9f2737113f4e5d41, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Curve2dFile {
  Curve2dFile() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e0ef9ef5efeaa0ec, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class Curve2d::Reader {
public:
  typedef Curve2d Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline  ::uint32_t getIndex() const;

  inline bool isLine() const;
  inline bool hasLine() const;
  inline  ::Line2d::Reader getLine() const;

  inline bool isCircle() const;
  inline bool hasCircle() const;
  inline  ::Circle2d::Reader getCircle() const;

  inline bool isEllipse() const;
  inline bool hasEllipse() const;
  inline  ::Ellipse2d::Reader getEllipse() const;

  inline bool isHyperbola() const;
  inline bool hasHyperbola() const;
  inline  ::Hyperbola2d::Reader getHyperbola() const;

  inline bool isParabola() const;
  inline bool hasParabola() const;
  inline  ::Parabola2d::Reader getParabola() const;

  inline bool isBezierCurve() const;
  inline bool hasBezierCurve() const;
  inline  ::BezierCurve2d::Reader getBezierCurve() const;

  inline bool isBsplineCurve() const;
  inline bool hasBsplineCurve() const;
  inline  ::BSplineCurve2d::Reader getBsplineCurve() const;

  inline bool isTrimmedCurve() const;
  inline bool hasTrimmedCurve() const;
  inline  ::TrimmedCurve2d::Reader getTrimmedCurve() const;

  inline bool isOffsetCurve() const;
  inline bool hasOffsetCurve() const;
  inline  ::OffsetCurve2d::Reader getOffsetCurve() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Curve2d::Builder {
public:
  typedef Curve2d Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline  ::uint32_t getIndex();
  inline void setIndex( ::uint32_t value);

  inline bool isLine();
  inline bool hasLine();
  inline  ::Line2d::Builder getLine();
  inline void setLine( ::Line2d::Reader value);
  inline  ::Line2d::Builder initLine();
  inline void adoptLine(::capnp::Orphan< ::Line2d>&& value);
  inline ::capnp::Orphan< ::Line2d> disownLine();

  inline bool isCircle();
  inline bool hasCircle();
  inline  ::Circle2d::Builder getCircle();
  inline void setCircle( ::Circle2d::Reader value);
  inline  ::Circle2d::Builder initCircle();
  inline void adoptCircle(::capnp::Orphan< ::Circle2d>&& value);
  inline ::capnp::Orphan< ::Circle2d> disownCircle();

  inline bool isEllipse();
  inline bool hasEllipse();
  inline  ::Ellipse2d::Builder getEllipse();
  inline void setEllipse( ::Ellipse2d::Reader value);
  inline  ::Ellipse2d::Builder initEllipse();
  inline void adoptEllipse(::capnp::Orphan< ::Ellipse2d>&& value);
  inline ::capnp::Orphan< ::Ellipse2d> disownEllipse();

  inline bool isHyperbola();
  inline bool hasHyperbola();
  inline  ::Hyperbola2d::Builder getHyperbola();
  inline void setHyperbola( ::Hyperbola2d::Reader value);
  inline  ::Hyperbola2d::Builder initHyperbola();
  inline void adoptHyperbola(::capnp::Orphan< ::Hyperbola2d>&& value);
  inline ::capnp::Orphan< ::Hyperbola2d> disownHyperbola();

  inline bool isParabola();
  inline bool hasParabola();
  inline  ::Parabola2d::Builder getParabola();
  inline void setParabola( ::Parabola2d::Reader value);
  inline  ::Parabola2d::Builder initParabola();
  inline void adoptParabola(::capnp::Orphan< ::Parabola2d>&& value);
  inline ::capnp::Orphan< ::Parabola2d> disownParabola();

  inline bool isBezierCurve();
  inline bool hasBezierCurve();
  inline  ::BezierCurve2d::Builder getBezierCurve();
  inline void setBezierCurve( ::BezierCurve2d::Reader value);
  inline  ::BezierCurve2d::Builder initBezierCurve();
  inline void adoptBezierCurve(::capnp::Orphan< ::BezierCurve2d>&& value);
  inline ::capnp::Orphan< ::BezierCurve2d> disownBezierCurve();

  inline bool isBsplineCurve();
  inline bool hasBsplineCurve();
  inline  ::BSplineCurve2d::Builder getBsplineCurve();
  inline void setBsplineCurve( ::BSplineCurve2d::Reader value);
  inline  ::BSplineCurve2d::Builder initBsplineCurve();
  inline void adoptBsplineCurve(::capnp::Orphan< ::BSplineCurve2d>&& value);
  inline ::capnp::Orphan< ::BSplineCurve2d> disownBsplineCurve();

  inline bool isTrimmedCurve();
  inline bool hasTrimmedCurve();
  inline  ::TrimmedCurve2d::Builder getTrimmedCurve();
  inline void setTrimmedCurve( ::TrimmedCurve2d::Reader value);
  inline  ::TrimmedCurve2d::Builder initTrimmedCurve();
  inline void adoptTrimmedCurve(::capnp::Orphan< ::TrimmedCurve2d>&& value);
  inline ::capnp::Orphan< ::TrimmedCurve2d> disownTrimmedCurve();

  inline bool isOffsetCurve();
  inline bool hasOffsetCurve();
  inline  ::OffsetCurve2d::Builder getOffsetCurve();
  inline void setOffsetCurve( ::OffsetCurve2d::Reader value);
  inline  ::OffsetCurve2d::Builder initOffsetCurve();
  inline void adoptOffsetCurve(::capnp::Orphan< ::OffsetCurve2d>&& value);
  inline ::capnp::Orphan< ::OffsetCurve2d> disownOffsetCurve();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Curve2d::Pipeline {
public:
  typedef Curve2d Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Line2d::Reader {
public:
  typedef Line2d Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasLocation() const;
  inline  ::Vec2::Reader getLocation() const;

  inline bool hasDirection() const;
  inline  ::Vec2::Reader getDirection() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Line2d::Builder {
public:
  typedef Line2d Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasLocation();
  inline  ::Vec2::Builder getLocation();
  inline void setLocation( ::Vec2::Reader value);
  inline  ::Vec2::Builder initLocation();
  inline void adoptLocation(::capnp::Orphan< ::Vec2>&& value);
  inline ::capnp::Orphan< ::Vec2> disownLocation();

  inline bool hasDirection();
  inline  ::Vec2::Builder getDirection();
  inline void setDirection( ::Vec2::Reader value);
  inline  ::Vec2::Builder initDirection();
  inline void adoptDirection(::capnp::Orphan< ::Vec2>&& value);
  inline ::capnp::Orphan< ::Vec2> disownDirection();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Line2d::Pipeline {
public:
  typedef Line2d Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::Vec2::Pipeline getLocation();
  inline  ::Vec2::Pipeline getDirection();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Circle2d::Reader {
public:
  typedef Circle2d Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPosition() const;
  inline  ::AxisPlacement2d::Reader getPosition() const;

  inline double getRadius() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Circle2d::Builder {
public:
  typedef Circle2d Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPosition();
  inline  ::AxisPlacement2d::Builder getPosition();
  inline void setPosition( ::AxisPlacement2d::Reader value);
  inline  ::AxisPlacement2d::Builder initPosition();
  inline void adoptPosition(::capnp::Orphan< ::AxisPlacement2d>&& value);
  inline ::capnp::Orphan< ::AxisPlacement2d> disownPosition();

  inline double getRadius();
  inline void setRadius(double value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Circle2d::Pipeline {
public:
  typedef Circle2d Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::AxisPlacement2d::Pipeline getPosition();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Ellipse2d::Reader {
public:
  typedef Ellipse2d Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPosition() const;
  inline  ::AxisPlacement2d::Reader getPosition() const;

  inline double getMajorRadius() const;

  inline double getMinorRadius() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Ellipse2d::Builder {
public:
  typedef Ellipse2d Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPosition();
  inline  ::AxisPlacement2d::Builder getPosition();
  inline void setPosition( ::AxisPlacement2d::Reader value);
  inline  ::AxisPlacement2d::Builder initPosition();
  inline void adoptPosition(::capnp::Orphan< ::AxisPlacement2d>&& value);
  inline ::capnp::Orphan< ::AxisPlacement2d> disownPosition();

  inline double getMajorRadius();
  inline void setMajorRadius(double value);

  inline double getMinorRadius();
  inline void setMinorRadius(double value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Ellipse2d::Pipeline {
public:
  typedef Ellipse2d Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::AxisPlacement2d::Pipeline getPosition();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Hyperbola2d::Reader {
public:
  typedef Hyperbola2d Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPosition() const;
  inline  ::AxisPlacement2d::Reader getPosition() const;

  inline double getMajorRadius() const;

  inline double getMinorRadius() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Hyperbola2d::Builder {
public:
  typedef Hyperbola2d Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPosition();
  inline  ::AxisPlacement2d::Builder getPosition();
  inline void setPosition( ::AxisPlacement2d::Reader value);
  inline  ::AxisPlacement2d::Builder initPosition();
  inline void adoptPosition(::capnp::Orphan< ::AxisPlacement2d>&& value);
  inline ::capnp::Orphan< ::AxisPlacement2d> disownPosition();

  inline double getMajorRadius();
  inline void setMajorRadius(double value);

  inline double getMinorRadius();
  inline void setMinorRadius(double value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Hyperbola2d::Pipeline {
public:
  typedef Hyperbola2d Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::AxisPlacement2d::Pipeline getPosition();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Parabola2d::Reader {
public:
  typedef Parabola2d Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPosition() const;
  inline  ::AxisPlacement2d::Reader getPosition() const;

  inline double getFocalLength() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Parabola2d::Builder {
public:
  typedef Parabola2d Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPosition();
  inline  ::AxisPlacement2d::Builder getPosition();
  inline void setPosition( ::AxisPlacement2d::Reader value);
  inline  ::AxisPlacement2d::Builder initPosition();
  inline void adoptPosition(::capnp::Orphan< ::AxisPlacement2d>&& value);
  inline ::capnp::Orphan< ::AxisPlacement2d> disownPosition();

  inline double getFocalLength();
  inline void setFocalLength(double value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Parabola2d::Pipeline {
public:
  typedef Parabola2d Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::AxisPlacement2d::Pipeline getPosition();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class BezierCurve2d::Reader {
public:
  typedef BezierCurve2d Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getDegree() const;

  inline bool hasPoles() const;
  inline  ::capnp::List< ::Vec2,  ::capnp::Kind::STRUCT>::Reader getPoles() const;

  inline bool hasWeights() const;
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader getWeights() const;

  inline bool getRational() const;

  inline bool getPeriodic() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class BezierCurve2d::Builder {
public:
  typedef BezierCurve2d Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getDegree();
  inline void setDegree( ::uint32_t value);

  inline bool hasPoles();
  inline  ::capnp::List< ::Vec2,  ::capnp::Kind::STRUCT>::Builder getPoles();
  inline void setPoles( ::capnp::List< ::Vec2,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::Vec2,  ::capnp::Kind::STRUCT>::Builder initPoles(unsigned int size);
  inline void adoptPoles(::capnp::Orphan< ::capnp::List< ::Vec2,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::Vec2,  ::capnp::Kind::STRUCT>> disownPoles();

  inline bool hasWeights();
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder getWeights();
  inline void setWeights( ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setWeights(::kj::ArrayPtr<const double> value);
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder initWeights(unsigned int size);
  inline void adoptWeights(::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>> disownWeights();

  inline bool getRational();
  inline void setRational(bool value);

  inline bool getPeriodic();
  inline void setPeriodic(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class BezierCurve2d::Pipeline {
public:
  typedef BezierCurve2d Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class BSplineCurve2d::Reader {
public:
  typedef BSplineCurve2d Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getDegree() const;

  inline bool hasKnots() const;
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader getKnots() const;

  inline bool hasMultiplicities() const;
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader getMultiplicities() const;

  inline bool hasPoles() const;
  inline  ::capnp::List< ::Vec2,  ::capnp::Kind::STRUCT>::Reader getPoles() const;

  inline bool hasWeights() const;
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader getWeights() const;

  inline bool getRational() const;

  inline bool getPeriodic() const;

  inline bool getClosed() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class BSplineCurve2d::Builder {
public:
  typedef BSplineCurve2d Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getDegree();
  inline void setDegree( ::uint32_t value);

  inline bool hasKnots();
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder getKnots();
  inline void setKnots( ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setKnots(::kj::ArrayPtr<const double> value);
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder initKnots(unsigned int size);
  inline void adoptKnots(::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>> disownKnots();

  inline bool hasMultiplicities();
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder getMultiplicities();
  inline void setMultiplicities( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setMultiplicities(::kj::ArrayPtr<const  ::uint32_t> value);
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder initMultiplicities(unsigned int size);
  inline void adoptMultiplicities(::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> disownMultiplicities();

  inline bool hasPoles();
  inline  ::capnp::List< ::Vec2,  ::capnp::Kind::STRUCT>::Builder getPoles();
  inline void setPoles( ::capnp::List< ::Vec2,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::Vec2,  ::capnp::Kind::STRUCT>::Builder initPoles(unsigned int size);
  inline void adoptPoles(::capnp::Orphan< ::capnp::List< ::Vec2,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::Vec2,  ::capnp::Kind::STRUCT>> disownPoles();

  inline bool hasWeights();
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder getWeights();
  inline void setWeights( ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setWeights(::kj::ArrayPtr<const double> value);
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder initWeights(unsigned int size);
  inline void adoptWeights(::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>> disownWeights();

  inline bool getRational();
  inline void setRational(bool value);

  inline bool getPeriodic();
  inline void setPeriodic(bool value);

  inline bool getClosed();
  inline void setClosed(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class BSplineCurve2d::Pipeline {
public:
  typedef BSplineCurve2d Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TrimmedCurve2d::Reader {
public:
  typedef TrimmedCurve2d Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasBasisCurve() const;
  inline  ::ObjectRef::Reader getBasisCurve() const;

  inline double getFirstParameter() const;

  inline double getLastParameter() const;

  inline bool getSense() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TrimmedCurve2d::Builder {
public:
  typedef TrimmedCurve2d Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasBasisCurve();
  inline  ::ObjectRef::Builder getBasisCurve();
  inline void setBasisCurve( ::ObjectRef::Reader value);
  inline  ::ObjectRef::Builder initBasisCurve();
  inline void adoptBasisCurve(::capnp::Orphan< ::ObjectRef>&& value);
  inline ::capnp::Orphan< ::ObjectRef> disownBasisCurve();

  inline double getFirstParameter();
  inline void setFirstParameter(double value);

  inline double getLastParameter();
  inline void setLastParameter(double value);

  inline bool getSense();
  inline void setSense(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TrimmedCurve2d::Pipeline {
public:
  typedef TrimmedCurve2d Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::ObjectRef::Pipeline getBasisCurve();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class OffsetCurve2d::Reader {
public:
  typedef OffsetCurve2d Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasBasisCurve() const;
  inline  ::ObjectRef::Reader getBasisCurve() const;

  inline double getOffset() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class OffsetCurve2d::Builder {
public:
  typedef OffsetCurve2d Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasBasisCurve();
  inline  ::ObjectRef::Builder getBasisCurve();
  inline void setBasisCurve( ::ObjectRef::Reader value);
  inline  ::ObjectRef::Builder initBasisCurve();
  inline void adoptBasisCurve(::capnp::Orphan< ::ObjectRef>&& value);
  inline ::capnp::Orphan< ::ObjectRef> disownBasisCurve();

  inline double getOffset();
  inline void setOffset(double value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class OffsetCurve2d::Pipeline {
public:
  typedef OffsetCurve2d Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::ObjectRef::Pipeline getBasisCurve();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Curve2dFile::Reader {
public:
  typedef Curve2dFile Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasCurves() const;
  inline  ::capnp::List< ::Curve2d,  ::capnp::Kind::STRUCT>::Reader getCurves() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Curve2dFile::Builder {
public:
  typedef Curve2dFile Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasCurves();
  inline  ::capnp::List< ::Curve2d,  ::capnp::Kind::STRUCT>::Builder getCurves();
  inline void setCurves( ::capnp::List< ::Curve2d,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::Curve2d,  ::capnp::Kind::STRUCT>::Builder initCurves(unsigned int size);
  inline void adoptCurves(::capnp::Orphan< ::capnp::List< ::Curve2d,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::Curve2d,  ::capnp::Kind::STRUCT>> disownCurves();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Curve2dFile::Pipeline {
public:
  typedef Curve2dFile Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline  ::Curve2d::Which Curve2d::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline  ::Curve2d::Which Curve2d::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Curve2d::Reader::getIndex() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Curve2d::Builder::getIndex() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Curve2d::Builder::setIndex( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Curve2d::Reader::isLine() const {
  return which() == Curve2d::LINE;
}
inline bool Curve2d::Builder::isLine() {
  return which() == Curve2d::LINE;
}
inline bool Curve2d::Reader::hasLine() const {
  if (which() != Curve2d::LINE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Curve2d::Builder::hasLine() {
  if (which() != Curve2d::LINE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::Line2d::Reader Curve2d::Reader::getLine() const {
  KJ_IREQUIRE((which() == Curve2d::LINE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Line2d>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::Line2d::Builder Curve2d::Builder::getLine() {
  KJ_IREQUIRE((which() == Curve2d::LINE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Line2d>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Curve2d::Builder::setLine( ::Line2d::Reader value) {
  _builder.setDataField<Curve2d::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Curve2d::LINE);
  ::capnp::_::PointerHelpers< ::Line2d>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::Line2d::Builder Curve2d::Builder::initLine() {
  _builder.setDataField<Curve2d::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Curve2d::LINE);
  return ::capnp::_::PointerHelpers< ::Line2d>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Curve2d::Builder::adoptLine(
    ::capnp::Orphan< ::Line2d>&& value) {
  _builder.setDataField<Curve2d::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Curve2d::LINE);
  ::capnp::_::PointerHelpers< ::Line2d>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Line2d> Curve2d::Builder::disownLine() {
  KJ_IREQUIRE((which() == Curve2d::LINE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Line2d>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Curve2d::Reader::isCircle() const {
  return which() == Curve2d::CIRCLE;
}
inline bool Curve2d::Builder::isCircle() {
  return which() == Curve2d::CIRCLE;
}
inline bool Curve2d::Reader::hasCircle() const {
  if (which() != Curve2d::CIRCLE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Curve2d::Builder::hasCircle() {
  if (which() != Curve2d::CIRCLE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::Circle2d::Reader Curve2d::Reader::getCircle() const {
  KJ_IREQUIRE((which() == Curve2d::CIRCLE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Circle2d>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::Circle2d::Builder Curve2d::Builder::getCircle() {
  KJ_IREQUIRE((which() == Curve2d::CIRCLE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Circle2d>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Curve2d::Builder::setCircle( ::Circle2d::Reader value) {
  _builder.setDataField<Curve2d::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Curve2d::CIRCLE);
  ::capnp::_::PointerHelpers< ::Circle2d>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::Circle2d::Builder Curve2d::Builder::initCircle() {
  _builder.setDataField<Curve2d::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Curve2d::CIRCLE);
  return ::capnp::_::PointerHelpers< ::Circle2d>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Curve2d::Builder::adoptCircle(
    ::capnp::Orphan< ::Circle2d>&& value) {
  _builder.setDataField<Curve2d::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Curve2d::CIRCLE);
  ::capnp::_::PointerHelpers< ::Circle2d>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Circle2d> Curve2d::Builder::disownCircle() {
  KJ_IREQUIRE((which() == Curve2d::CIRCLE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Circle2d>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Curve2d::Reader::isEllipse() const {
  return which() == Curve2d::ELLIPSE;
}
inline bool Curve2d::Builder::isEllipse() {
  return which() == Curve2d::ELLIPSE;
}
inline bool Curve2d::Reader::hasEllipse() const {
  if (which() != Curve2d::ELLIPSE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Curve2d::Builder::hasEllipse() {
  if (which() != Curve2d::ELLIPSE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::Ellipse2d::Reader Curve2d::Reader::getEllipse() const {
  KJ_IREQUIRE((which() == Curve2d::ELLIPSE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Ellipse2d>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::Ellipse2d::Builder Curve2d::Builder::getEllipse() {
  KJ_IREQUIRE((which() == Curve2d::ELLIPSE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Ellipse2d>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Curve2d::Builder::setEllipse( ::Ellipse2d::Reader value) {
  _builder.setDataField<Curve2d::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Curve2d::ELLIPSE);
  ::capnp::_::PointerHelpers< ::Ellipse2d>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::Ellipse2d::Builder Curve2d::Builder::initEllipse() {
  _builder.setDataField<Curve2d::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Curve2d::ELLIPSE);
  return ::capnp::_::PointerHelpers< ::Ellipse2d>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Curve2d::Builder::adoptEllipse(
    ::capnp::Orphan< ::Ellipse2d>&& value) {
  _builder.setDataField<Curve2d::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Curve2d::ELLIPSE);
  ::capnp::_::PointerHelpers< ::Ellipse2d>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Ellipse2d> Curve2d::Builder::disownEllipse() {
  KJ_IREQUIRE((which() == Curve2d::ELLIPSE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Ellipse2d>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Curve2d::Reader::isHyperbola() const {
  return which() == Curve2d::HYPERBOLA;
}
inline bool Curve2d::Builder::isHyperbola() {
  return which() == Curve2d::HYPERBOLA;
}
inline bool Curve2d::Reader::hasHyperbola() const {
  if (which() != Curve2d::HYPERBOLA) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Curve2d::Builder::hasHyperbola() {
  if (which() != Curve2d::HYPERBOLA) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::Hyperbola2d::Reader Curve2d::Reader::getHyperbola() const {
  KJ_IREQUIRE((which() == Curve2d::HYPERBOLA),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Hyperbola2d>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::Hyperbola2d::Builder Curve2d::Builder::getHyperbola() {
  KJ_IREQUIRE((which() == Curve2d::HYPERBOLA),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Hyperbola2d>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Curve2d::Builder::setHyperbola( ::Hyperbola2d::Reader value) {
  _builder.setDataField<Curve2d::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Curve2d::HYPERBOLA);
  ::capnp::_::PointerHelpers< ::Hyperbola2d>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::Hyperbola2d::Builder Curve2d::Builder::initHyperbola() {
  _builder.setDataField<Curve2d::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Curve2d::HYPERBOLA);
  return ::capnp::_::PointerHelpers< ::Hyperbola2d>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Curve2d::Builder::adoptHyperbola(
    ::capnp::Orphan< ::Hyperbola2d>&& value) {
  _builder.setDataField<Curve2d::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Curve2d::HYPERBOLA);
  ::capnp::_::PointerHelpers< ::Hyperbola2d>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Hyperbola2d> Curve2d::Builder::disownHyperbola() {
  KJ_IREQUIRE((which() == Curve2d::HYPERBOLA),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Hyperbola2d>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Curve2d::Reader::isParabola() const {
  return which() == Curve2d::PARABOLA;
}
inline bool Curve2d::Builder::isParabola() {
  return which() == Curve2d::PARABOLA;
}
inline bool Curve2d::Reader::hasParabola() const {
  if (which() != Curve2d::PARABOLA) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Curve2d::Builder::hasParabola() {
  if (which() != Curve2d::PARABOLA) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::Parabola2d::Reader Curve2d::Reader::getParabola() const {
  KJ_IREQUIRE((which() == Curve2d::PARABOLA),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Parabola2d>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::Parabola2d::Builder Curve2d::Builder::getParabola() {
  KJ_IREQUIRE((which() == Curve2d::PARABOLA),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Parabola2d>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Curve2d::Builder::setParabola( ::Parabola2d::Reader value) {
  _builder.setDataField<Curve2d::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Curve2d::PARABOLA);
  ::capnp::_::PointerHelpers< ::Parabola2d>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::Parabola2d::Builder Curve2d::Builder::initParabola() {
  _builder.setDataField<Curve2d::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Curve2d::PARABOLA);
  return ::capnp::_::PointerHelpers< ::Parabola2d>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Curve2d::Builder::adoptParabola(
    ::capnp::Orphan< ::Parabola2d>&& value) {
  _builder.setDataField<Curve2d::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Curve2d::PARABOLA);
  ::capnp::_::PointerHelpers< ::Parabola2d>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Parabola2d> Curve2d::Builder::disownParabola() {
  KJ_IREQUIRE((which() == Curve2d::PARABOLA),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Parabola2d>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Curve2d::Reader::isBezierCurve() const {
  return which() == Curve2d::BEZIER_CURVE;
}
inline bool Curve2d::Builder::isBezierCurve() {
  return which() == Curve2d::BEZIER_CURVE;
}
inline bool Curve2d::Reader::hasBezierCurve() const {
  if (which() != Curve2d::BEZIER_CURVE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Curve2d::Builder::hasBezierCurve() {
  if (which() != Curve2d::BEZIER_CURVE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::BezierCurve2d::Reader Curve2d::Reader::getBezierCurve() const {
  KJ_IREQUIRE((which() == Curve2d::BEZIER_CURVE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::BezierCurve2d>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::BezierCurve2d::Builder Curve2d::Builder::getBezierCurve() {
  KJ_IREQUIRE((which() == Curve2d::BEZIER_CURVE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::BezierCurve2d>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Curve2d::Builder::setBezierCurve( ::BezierCurve2d::Reader value) {
  _builder.setDataField<Curve2d::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Curve2d::BEZIER_CURVE);
  ::capnp::_::PointerHelpers< ::BezierCurve2d>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::BezierCurve2d::Builder Curve2d::Builder::initBezierCurve() {
  _builder.setDataField<Curve2d::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Curve2d::BEZIER_CURVE);
  return ::capnp::_::PointerHelpers< ::BezierCurve2d>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Curve2d::Builder::adoptBezierCurve(
    ::capnp::Orphan< ::BezierCurve2d>&& value) {
  _builder.setDataField<Curve2d::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Curve2d::BEZIER_CURVE);
  ::capnp::_::PointerHelpers< ::BezierCurve2d>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::BezierCurve2d> Curve2d::Builder::disownBezierCurve() {
  KJ_IREQUIRE((which() == Curve2d::BEZIER_CURVE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::BezierCurve2d>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Curve2d::Reader::isBsplineCurve() const {
  return which() == Curve2d::BSPLINE_CURVE;
}
inline bool Curve2d::Builder::isBsplineCurve() {
  return which() == Curve2d::BSPLINE_CURVE;
}
inline bool Curve2d::Reader::hasBsplineCurve() const {
  if (which() != Curve2d::BSPLINE_CURVE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Curve2d::Builder::hasBsplineCurve() {
  if (which() != Curve2d::BSPLINE_CURVE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::BSplineCurve2d::Reader Curve2d::Reader::getBsplineCurve() const {
  KJ_IREQUIRE((which() == Curve2d::BSPLINE_CURVE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::BSplineCurve2d>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::BSplineCurve2d::Builder Curve2d::Builder::getBsplineCurve() {
  KJ_IREQUIRE((which() == Curve2d::BSPLINE_CURVE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::BSplineCurve2d>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Curve2d::Builder::setBsplineCurve( ::BSplineCurve2d::Reader value) {
  _builder.setDataField<Curve2d::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Curve2d::BSPLINE_CURVE);
  ::capnp::_::PointerHelpers< ::BSplineCurve2d>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::BSplineCurve2d::Builder Curve2d::Builder::initBsplineCurve() {
  _builder.setDataField<Curve2d::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Curve2d::BSPLINE_CURVE);
  return ::capnp::_::PointerHelpers< ::BSplineCurve2d>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Curve2d::Builder::adoptBsplineCurve(
    ::capnp::Orphan< ::BSplineCurve2d>&& value) {
  _builder.setDataField<Curve2d::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Curve2d::BSPLINE_CURVE);
  ::capnp::_::PointerHelpers< ::BSplineCurve2d>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::BSplineCurve2d> Curve2d::Builder::disownBsplineCurve() {
  KJ_IREQUIRE((which() == Curve2d::BSPLINE_CURVE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::BSplineCurve2d>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Curve2d::Reader::isTrimmedCurve() const {
  return which() == Curve2d::TRIMMED_CURVE;
}
inline bool Curve2d::Builder::isTrimmedCurve() {
  return which() == Curve2d::TRIMMED_CURVE;
}
inline bool Curve2d::Reader::hasTrimmedCurve() const {
  if (which() != Curve2d::TRIMMED_CURVE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Curve2d::Builder::hasTrimmedCurve() {
  if (which() != Curve2d::TRIMMED_CURVE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::TrimmedCurve2d::Reader Curve2d::Reader::getTrimmedCurve() const {
  KJ_IREQUIRE((which() == Curve2d::TRIMMED_CURVE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::TrimmedCurve2d>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::TrimmedCurve2d::Builder Curve2d::Builder::getTrimmedCurve() {
  KJ_IREQUIRE((which() == Curve2d::TRIMMED_CURVE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::TrimmedCurve2d>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Curve2d::Builder::setTrimmedCurve( ::TrimmedCurve2d::Reader value) {
  _builder.setDataField<Curve2d::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Curve2d::TRIMMED_CURVE);
  ::capnp::_::PointerHelpers< ::TrimmedCurve2d>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::TrimmedCurve2d::Builder Curve2d::Builder::initTrimmedCurve() {
  _builder.setDataField<Curve2d::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Curve2d::TRIMMED_CURVE);
  return ::capnp::_::PointerHelpers< ::TrimmedCurve2d>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Curve2d::Builder::adoptTrimmedCurve(
    ::capnp::Orphan< ::TrimmedCurve2d>&& value) {
  _builder.setDataField<Curve2d::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Curve2d::TRIMMED_CURVE);
  ::capnp::_::PointerHelpers< ::TrimmedCurve2d>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::TrimmedCurve2d> Curve2d::Builder::disownTrimmedCurve() {
  KJ_IREQUIRE((which() == Curve2d::TRIMMED_CURVE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::TrimmedCurve2d>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Curve2d::Reader::isOffsetCurve() const {
  return which() == Curve2d::OFFSET_CURVE;
}
inline bool Curve2d::Builder::isOffsetCurve() {
  return which() == Curve2d::OFFSET_CURVE;
}
inline bool Curve2d::Reader::hasOffsetCurve() const {
  if (which() != Curve2d::OFFSET_CURVE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Curve2d::Builder::hasOffsetCurve() {
  if (which() != Curve2d::OFFSET_CURVE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::OffsetCurve2d::Reader Curve2d::Reader::getOffsetCurve() const {
  KJ_IREQUIRE((which() == Curve2d::OFFSET_CURVE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::OffsetCurve2d>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::OffsetCurve2d::Builder Curve2d::Builder::getOffsetCurve() {
  KJ_IREQUIRE((which() == Curve2d::OFFSET_CURVE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::OffsetCurve2d>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Curve2d::Builder::setOffsetCurve( ::OffsetCurve2d::Reader value) {
  _builder.setDataField<Curve2d::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Curve2d::OFFSET_CURVE);
  ::capnp::_::PointerHelpers< ::OffsetCurve2d>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::OffsetCurve2d::Builder Curve2d::Builder::initOffsetCurve() {
  _builder.setDataField<Curve2d::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Curve2d::OFFSET_CURVE);
  return ::capnp::_::PointerHelpers< ::OffsetCurve2d>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Curve2d::Builder::adoptOffsetCurve(
    ::capnp::Orphan< ::OffsetCurve2d>&& value) {
  _builder.setDataField<Curve2d::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Curve2d::OFFSET_CURVE);
  ::capnp::_::PointerHelpers< ::OffsetCurve2d>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::OffsetCurve2d> Curve2d::Builder::disownOffsetCurve() {
  KJ_IREQUIRE((which() == Curve2d::OFFSET_CURVE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::OffsetCurve2d>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Line2d::Reader::hasLocation() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Line2d::Builder::hasLocation() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::Vec2::Reader Line2d::Reader::getLocation() const {
  return ::capnp::_::PointerHelpers< ::Vec2>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::Vec2::Builder Line2d::Builder::getLocation() {
  return ::capnp::_::PointerHelpers< ::Vec2>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Vec2::Pipeline Line2d::Pipeline::getLocation() {
  return  ::Vec2::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Line2d::Builder::setLocation( ::Vec2::Reader value) {
  ::capnp::_::PointerHelpers< ::Vec2>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::Vec2::Builder Line2d::Builder::initLocation() {
  return ::capnp::_::PointerHelpers< ::Vec2>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Line2d::Builder::adoptLocation(
    ::capnp::Orphan< ::Vec2>&& value) {
  ::capnp::_::PointerHelpers< ::Vec2>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Vec2> Line2d::Builder::disownLocation() {
  return ::capnp::_::PointerHelpers< ::Vec2>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Line2d::Reader::hasDirection() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Line2d::Builder::hasDirection() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::Vec2::Reader Line2d::Reader::getDirection() const {
  return ::capnp::_::PointerHelpers< ::Vec2>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::Vec2::Builder Line2d::Builder::getDirection() {
  return ::capnp::_::PointerHelpers< ::Vec2>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Vec2::Pipeline Line2d::Pipeline::getDirection() {
  return  ::Vec2::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Line2d::Builder::setDirection( ::Vec2::Reader value) {
  ::capnp::_::PointerHelpers< ::Vec2>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::Vec2::Builder Line2d::Builder::initDirection() {
  return ::capnp::_::PointerHelpers< ::Vec2>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Line2d::Builder::adoptDirection(
    ::capnp::Orphan< ::Vec2>&& value) {
  ::capnp::_::PointerHelpers< ::Vec2>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Vec2> Line2d::Builder::disownDirection() {
  return ::capnp::_::PointerHelpers< ::Vec2>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Circle2d::Reader::hasPosition() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Circle2d::Builder::hasPosition() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::AxisPlacement2d::Reader Circle2d::Reader::getPosition() const {
  return ::capnp::_::PointerHelpers< ::AxisPlacement2d>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::AxisPlacement2d::Builder Circle2d::Builder::getPosition() {
  return ::capnp::_::PointerHelpers< ::AxisPlacement2d>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::AxisPlacement2d::Pipeline Circle2d::Pipeline::getPosition() {
  return  ::AxisPlacement2d::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Circle2d::Builder::setPosition( ::AxisPlacement2d::Reader value) {
  ::capnp::_::PointerHelpers< ::AxisPlacement2d>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::AxisPlacement2d::Builder Circle2d::Builder::initPosition() {
  return ::capnp::_::PointerHelpers< ::AxisPlacement2d>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Circle2d::Builder::adoptPosition(
    ::capnp::Orphan< ::AxisPlacement2d>&& value) {
  ::capnp::_::PointerHelpers< ::AxisPlacement2d>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::AxisPlacement2d> Circle2d::Builder::disownPosition() {
  return ::capnp::_::PointerHelpers< ::AxisPlacement2d>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline double Circle2d::Reader::getRadius() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline double Circle2d::Builder::getRadius() {
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Circle2d::Builder::setRadius(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Ellipse2d::Reader::hasPosition() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Ellipse2d::Builder::hasPosition() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::AxisPlacement2d::Reader Ellipse2d::Reader::getPosition() const {
  return ::capnp::_::PointerHelpers< ::AxisPlacement2d>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::AxisPlacement2d::Builder Ellipse2d::Builder::getPosition() {
  return ::capnp::_::PointerHelpers< ::AxisPlacement2d>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::AxisPlacement2d::Pipeline Ellipse2d::Pipeline::getPosition() {
  return  ::AxisPlacement2d::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Ellipse2d::Builder::setPosition( ::AxisPlacement2d::Reader value) {
  ::capnp::_::PointerHelpers< ::AxisPlacement2d>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::AxisPlacement2d::Builder Ellipse2d::Builder::initPosition() {
  return ::capnp::_::PointerHelpers< ::AxisPlacement2d>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Ellipse2d::Builder::adoptPosition(
    ::capnp::Orphan< ::AxisPlacement2d>&& value) {
  ::capnp::_::PointerHelpers< ::AxisPlacement2d>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::AxisPlacement2d> Ellipse2d::Builder::disownPosition() {
  return ::capnp::_::PointerHelpers< ::AxisPlacement2d>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline double Ellipse2d::Reader::getMajorRadius() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline double Ellipse2d::Builder::getMajorRadius() {
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Ellipse2d::Builder::setMajorRadius(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline double Ellipse2d::Reader::getMinorRadius() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline double Ellipse2d::Builder::getMinorRadius() {
  return _builder.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Ellipse2d::Builder::setMinorRadius(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Hyperbola2d::Reader::hasPosition() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Hyperbola2d::Builder::hasPosition() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::AxisPlacement2d::Reader Hyperbola2d::Reader::getPosition() const {
  return ::capnp::_::PointerHelpers< ::AxisPlacement2d>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::AxisPlacement2d::Builder Hyperbola2d::Builder::getPosition() {
  return ::capnp::_::PointerHelpers< ::AxisPlacement2d>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::AxisPlacement2d::Pipeline Hyperbola2d::Pipeline::getPosition() {
  return  ::AxisPlacement2d::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Hyperbola2d::Builder::setPosition( ::AxisPlacement2d::Reader value) {
  ::capnp::_::PointerHelpers< ::AxisPlacement2d>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::AxisPlacement2d::Builder Hyperbola2d::Builder::initPosition() {
  return ::capnp::_::PointerHelpers< ::AxisPlacement2d>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Hyperbola2d::Builder::adoptPosition(
    ::capnp::Orphan< ::AxisPlacement2d>&& value) {
  ::capnp::_::PointerHelpers< ::AxisPlacement2d>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::AxisPlacement2d> Hyperbola2d::Builder::disownPosition() {
  return ::capnp::_::PointerHelpers< ::AxisPlacement2d>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline double Hyperbola2d::Reader::getMajorRadius() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline double Hyperbola2d::Builder::getMajorRadius() {
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Hyperbola2d::Builder::setMajorRadius(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline double Hyperbola2d::Reader::getMinorRadius() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline double Hyperbola2d::Builder::getMinorRadius() {
  return _builder.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Hyperbola2d::Builder::setMinorRadius(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Parabola2d::Reader::hasPosition() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Parabola2d::Builder::hasPosition() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::AxisPlacement2d::Reader Parabola2d::Reader::getPosition() const {
  return ::capnp::_::PointerHelpers< ::AxisPlacement2d>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::AxisPlacement2d::Builder Parabola2d::Builder::getPosition() {
  return ::capnp::_::PointerHelpers< ::AxisPlacement2d>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::AxisPlacement2d::Pipeline Parabola2d::Pipeline::getPosition() {
  return  ::AxisPlacement2d::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Parabola2d::Builder::setPosition( ::AxisPlacement2d::Reader value) {
  ::capnp::_::PointerHelpers< ::AxisPlacement2d>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::AxisPlacement2d::Builder Parabola2d::Builder::initPosition() {
  return ::capnp::_::PointerHelpers< ::AxisPlacement2d>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Parabola2d::Builder::adoptPosition(
    ::capnp::Orphan< ::AxisPlacement2d>&& value) {
  ::capnp::_::PointerHelpers< ::AxisPlacement2d>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::AxisPlacement2d> Parabola2d::Builder::disownPosition() {
  return ::capnp::_::PointerHelpers< ::AxisPlacement2d>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline double Parabola2d::Reader::getFocalLength() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline double Parabola2d::Builder::getFocalLength() {
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Parabola2d::Builder::setFocalLength(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t BezierCurve2d::Reader::getDegree() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t BezierCurve2d::Builder::getDegree() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void BezierCurve2d::Builder::setDegree( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool BezierCurve2d::Reader::hasPoles() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool BezierCurve2d::Builder::hasPoles() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::Vec2,  ::capnp::Kind::STRUCT>::Reader BezierCurve2d::Reader::getPoles() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Vec2,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::Vec2,  ::capnp::Kind::STRUCT>::Builder BezierCurve2d::Builder::getPoles() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Vec2,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void BezierCurve2d::Builder::setPoles( ::capnp::List< ::Vec2,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Vec2,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::Vec2,  ::capnp::Kind::STRUCT>::Builder BezierCurve2d::Builder::initPoles(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Vec2,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void BezierCurve2d::Builder::adoptPoles(
    ::capnp::Orphan< ::capnp::List< ::Vec2,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Vec2,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::Vec2,  ::capnp::Kind::STRUCT>> BezierCurve2d::Builder::disownPoles() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Vec2,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool BezierCurve2d::Reader::hasWeights() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool BezierCurve2d::Builder::hasWeights() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader BezierCurve2d::Reader::getWeights() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder BezierCurve2d::Builder::getWeights() {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void BezierCurve2d::Builder::setWeights( ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline void BezierCurve2d::Builder::setWeights(::kj::ArrayPtr<const double> value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder BezierCurve2d::Builder::initWeights(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void BezierCurve2d::Builder::adoptWeights(
    ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>> BezierCurve2d::Builder::disownWeights() {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool BezierCurve2d::Reader::getRational() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<32>() * ::capnp::ELEMENTS);
}

inline bool BezierCurve2d::Builder::getRational() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<32>() * ::capnp::ELEMENTS);
}
inline void BezierCurve2d::Builder::setRational(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<32>() * ::capnp::ELEMENTS, value);
}

inline bool BezierCurve2d::Reader::getPeriodic() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<33>() * ::capnp::ELEMENTS);
}

inline bool BezierCurve2d::Builder::getPeriodic() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<33>() * ::capnp::ELEMENTS);
}
inline void BezierCurve2d::Builder::setPeriodic(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<33>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t BSplineCurve2d::Reader::getDegree() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t BSplineCurve2d::Builder::getDegree() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void BSplineCurve2d::Builder::setDegree( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool BSplineCurve2d::Reader::hasKnots() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool BSplineCurve2d::Builder::hasKnots() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader BSplineCurve2d::Reader::getKnots() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder BSplineCurve2d::Builder::getKnots() {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void BSplineCurve2d::Builder::setKnots( ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void BSplineCurve2d::Builder::setKnots(::kj::ArrayPtr<const double> value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder BSplineCurve2d::Builder::initKnots(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void BSplineCurve2d::Builder::adoptKnots(
    ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>> BSplineCurve2d::Builder::disownKnots() {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool BSplineCurve2d::Reader::hasMultiplicities() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool BSplineCurve2d::Builder::hasMultiplicities() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader BSplineCurve2d::Reader::getMultiplicities() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder BSplineCurve2d::Builder::getMultiplicities() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void BSplineCurve2d::Builder::setMultiplicities( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline void BSplineCurve2d::Builder::setMultiplicities(::kj::ArrayPtr<const  ::uint32_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder BSplineCurve2d::Builder::initMultiplicities(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void BSplineCurve2d::Builder::adoptMultiplicities(
    ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> BSplineCurve2d::Builder::disownMultiplicities() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool BSplineCurve2d::Reader::hasPoles() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool BSplineCurve2d::Builder::hasPoles() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::Vec2,  ::capnp::Kind::STRUCT>::Reader BSplineCurve2d::Reader::getPoles() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Vec2,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::Vec2,  ::capnp::Kind::STRUCT>::Builder BSplineCurve2d::Builder::getPoles() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Vec2,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void BSplineCurve2d::Builder::setPoles( ::capnp::List< ::Vec2,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Vec2,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::Vec2,  ::capnp::Kind::STRUCT>::Builder BSplineCurve2d::Builder::initPoles(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Vec2,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void BSplineCurve2d::Builder::adoptPoles(
    ::capnp::Orphan< ::capnp::List< ::Vec2,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Vec2,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::Vec2,  ::capnp::Kind::STRUCT>> BSplineCurve2d::Builder::disownPoles() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Vec2,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool BSplineCurve2d::Reader::hasWeights() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool BSplineCurve2d::Builder::hasWeights() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader BSplineCurve2d::Reader::getWeights() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder BSplineCurve2d::Builder::getWeights() {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void BSplineCurve2d::Builder::setWeights( ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline void BSplineCurve2d::Builder::setWeights(::kj::ArrayPtr<const double> value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder BSplineCurve2d::Builder::initWeights(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), size);
}
inline void BSplineCurve2d::Builder::adoptWeights(
    ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>> BSplineCurve2d::Builder::disownWeights() {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool BSplineCurve2d::Reader::getRational() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<32>() * ::capnp::ELEMENTS);
}

inline bool BSplineCurve2d::Builder::getRational() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<32>() * ::capnp::ELEMENTS);
}
inline void BSplineCurve2d::Builder::setRational(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<32>() * ::capnp::ELEMENTS, value);
}

inline bool BSplineCurve2d::Reader::getPeriodic() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<33>() * ::capnp::ELEMENTS);
}

inline bool BSplineCurve2d::Builder::getPeriodic() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<33>() * ::capnp::ELEMENTS);
}
inline void BSplineCurve2d::Builder::setPeriodic(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<33>() * ::capnp::ELEMENTS, value);
}

inline bool BSplineCurve2d::Reader::getClosed() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<34>() * ::capnp::ELEMENTS);
}

inline bool BSplineCurve2d::Builder::getClosed() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<34>() * ::capnp::ELEMENTS);
}
inline void BSplineCurve2d::Builder::setClosed(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<34>() * ::capnp::ELEMENTS, value);
}

inline bool TrimmedCurve2d::Reader::hasBasisCurve() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TrimmedCurve2d::Builder::hasBasisCurve() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::ObjectRef::Reader TrimmedCurve2d::Reader::getBasisCurve() const {
  return ::capnp::_::PointerHelpers< ::ObjectRef>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::ObjectRef::Builder TrimmedCurve2d::Builder::getBasisCurve() {
  return ::capnp::_::PointerHelpers< ::ObjectRef>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::ObjectRef::Pipeline TrimmedCurve2d::Pipeline::getBasisCurve() {
  return  ::ObjectRef::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void TrimmedCurve2d::Builder::setBasisCurve( ::ObjectRef::Reader value) {
  ::capnp::_::PointerHelpers< ::ObjectRef>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::ObjectRef::Builder TrimmedCurve2d::Builder::initBasisCurve() {
  return ::capnp::_::PointerHelpers< ::ObjectRef>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TrimmedCurve2d::Builder::adoptBasisCurve(
    ::capnp::Orphan< ::ObjectRef>&& value) {
  ::capnp::_::PointerHelpers< ::ObjectRef>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::ObjectRef> TrimmedCurve2d::Builder::disownBasisCurve() {
  return ::capnp::_::PointerHelpers< ::ObjectRef>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline double TrimmedCurve2d::Reader::getFirstParameter() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline double TrimmedCurve2d::Builder::getFirstParameter() {
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TrimmedCurve2d::Builder::setFirstParameter(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline double TrimmedCurve2d::Reader::getLastParameter() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline double TrimmedCurve2d::Builder::getLastParameter() {
  return _builder.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void TrimmedCurve2d::Builder::setLastParameter(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool TrimmedCurve2d::Reader::getSense() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<128>() * ::capnp::ELEMENTS, true);
}

inline bool TrimmedCurve2d::Builder::getSense() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<128>() * ::capnp::ELEMENTS, true);
}
inline void TrimmedCurve2d::Builder::setSense(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<128>() * ::capnp::ELEMENTS, value, true);
}

inline bool OffsetCurve2d::Reader::hasBasisCurve() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool OffsetCurve2d::Builder::hasBasisCurve() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::ObjectRef::Reader OffsetCurve2d::Reader::getBasisCurve() const {
  return ::capnp::_::PointerHelpers< ::ObjectRef>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::ObjectRef::Builder OffsetCurve2d::Builder::getBasisCurve() {
  return ::capnp::_::PointerHelpers< ::ObjectRef>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::ObjectRef::Pipeline OffsetCurve2d::Pipeline::getBasisCurve() {
  return  ::ObjectRef::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void OffsetCurve2d::Builder::setBasisCurve( ::ObjectRef::Reader value) {
  ::capnp::_::PointerHelpers< ::ObjectRef>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::ObjectRef::Builder OffsetCurve2d::Builder::initBasisCurve() {
  return ::capnp::_::PointerHelpers< ::ObjectRef>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void OffsetCurve2d::Builder::adoptBasisCurve(
    ::capnp::Orphan< ::ObjectRef>&& value) {
  ::capnp::_::PointerHelpers< ::ObjectRef>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::ObjectRef> OffsetCurve2d::Builder::disownBasisCurve() {
  return ::capnp::_::PointerHelpers< ::ObjectRef>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline double OffsetCurve2d::Reader::getOffset() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline double OffsetCurve2d::Builder::getOffset() {
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void OffsetCurve2d::Builder::setOffset(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Curve2dFile::Reader::hasCurves() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Curve2dFile::Builder::hasCurves() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::Curve2d,  ::capnp::Kind::STRUCT>::Reader Curve2dFile::Reader::getCurves() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Curve2d,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::Curve2d,  ::capnp::Kind::STRUCT>::Builder Curve2dFile::Builder::getCurves() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Curve2d,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Curve2dFile::Builder::setCurves( ::capnp::List< ::Curve2d,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Curve2d,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::Curve2d,  ::capnp::Kind::STRUCT>::Builder Curve2dFile::Builder::initCurves(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Curve2d,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Curve2dFile::Builder::adoptCurves(
    ::capnp::Orphan< ::capnp::List< ::Curve2d,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Curve2d,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::Curve2d,  ::capnp::Kind::STRUCT>> Curve2dFile::Builder::disownCurves() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Curve2d,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}


CAPNP_END_HEADER

