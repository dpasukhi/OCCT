// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: topology.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>

#ifndef CAPNP_VERSION
#error "CAPNP_VERSION is not defined, is capnp/generated-header-support.h missing?"
#elif CAPNP_VERSION != 1002000
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif

#include "ode.capnp.h"

CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(d2495d36940374d4);
enum class ShapeType_d2495d36940374d4: uint16_t {
  VERTEX,
  EDGE,
  WIRE,
  FACE,
  SHELL,
  SOLID,
  COMP_SOLID,
  COMPOUND,
};
CAPNP_DECLARE_ENUM(ShapeType, d2495d36940374d4);
CAPNP_DECLARE_SCHEMA(cd39ff300b46c190);
enum class Orientation_cd39ff300b46c190: uint16_t {
  FORWARD,
  REVERSED,
  INTERNAL,
  EXTERNAL,
};
CAPNP_DECLARE_ENUM(Orientation, cd39ff300b46c190);
CAPNP_DECLARE_SCHEMA(d4475225686af014);
CAPNP_DECLARE_SCHEMA(c9738b752810f647);
CAPNP_DECLARE_SCHEMA(fa78f505c730cf67);
CAPNP_DECLARE_SCHEMA(9f05d711a7a0ac84);
CAPNP_DECLARE_SCHEMA(e7588eaf0e8c763e);
CAPNP_DECLARE_SCHEMA(ca98495d93f81d99);
CAPNP_DECLARE_SCHEMA(da461bb81d3bc7a8);
CAPNP_DECLARE_SCHEMA(d894f3b516cd0be3);
CAPNP_DECLARE_SCHEMA(e6e90e56c00171cc);
CAPNP_DECLARE_SCHEMA(d000d949750dbc2f);
CAPNP_DECLARE_SCHEMA(b618cd028dadb3c0);

}  // namespace schemas
}  // namespace capnp


typedef ::capnp::schemas::ShapeType_d2495d36940374d4 ShapeType;

typedef ::capnp::schemas::Orientation_cd39ff300b46c190 Orientation;

struct Shape {
  Shape() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    VERTEX,
    EDGE,
    WIRE,
    FACE,
    SHELL,
    SOLID,
    COMP_SOLID,
    COMPOUND,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d4475225686af014, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Vertex {
  Vertex() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c9738b752810f647, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Edge {
  Edge() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fa78f505c730cf67, 4, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct PCurveOnFace {
  PCurveOnFace() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9f05d711a7a0ac84, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Wire {
  Wire() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e7588eaf0e8c763e, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Face {
  Face() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ca98495d93f81d99, 2, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Shell {
  Shell() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(da461bb81d3bc7a8, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Solid {
  Solid() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d894f3b516cd0be3, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct CompSolid {
  CompSolid() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e6e90e56c00171cc, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Compound {
  Compound() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d000d949750dbc2f, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TopologyFile {
  TopologyFile() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b618cd028dadb3c0, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class Shape::Reader {
public:
  typedef Shape Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline  ::uint32_t getIndex() const;

  inline  ::ShapeType getShapeType() const;

  inline  ::Orientation getOrientation() const;

  inline bool isVertex() const;
  inline bool hasVertex() const;
  inline  ::Vertex::Reader getVertex() const;

  inline bool isEdge() const;
  inline bool hasEdge() const;
  inline  ::Edge::Reader getEdge() const;

  inline bool isWire() const;
  inline bool hasWire() const;
  inline  ::Wire::Reader getWire() const;

  inline bool isFace() const;
  inline bool hasFace() const;
  inline  ::Face::Reader getFace() const;

  inline bool isShell() const;
  inline bool hasShell() const;
  inline  ::Shell::Reader getShell() const;

  inline bool isSolid() const;
  inline bool hasSolid() const;
  inline  ::Solid::Reader getSolid() const;

  inline bool isCompSolid() const;
  inline bool hasCompSolid() const;
  inline  ::CompSolid::Reader getCompSolid() const;

  inline bool isCompound() const;
  inline bool hasCompound() const;
  inline  ::Compound::Reader getCompound() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Shape::Builder {
public:
  typedef Shape Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline  ::uint32_t getIndex();
  inline void setIndex( ::uint32_t value);

  inline  ::ShapeType getShapeType();
  inline void setShapeType( ::ShapeType value);

  inline  ::Orientation getOrientation();
  inline void setOrientation( ::Orientation value);

  inline bool isVertex();
  inline bool hasVertex();
  inline  ::Vertex::Builder getVertex();
  inline void setVertex( ::Vertex::Reader value);
  inline  ::Vertex::Builder initVertex();
  inline void adoptVertex(::capnp::Orphan< ::Vertex>&& value);
  inline ::capnp::Orphan< ::Vertex> disownVertex();

  inline bool isEdge();
  inline bool hasEdge();
  inline  ::Edge::Builder getEdge();
  inline void setEdge( ::Edge::Reader value);
  inline  ::Edge::Builder initEdge();
  inline void adoptEdge(::capnp::Orphan< ::Edge>&& value);
  inline ::capnp::Orphan< ::Edge> disownEdge();

  inline bool isWire();
  inline bool hasWire();
  inline  ::Wire::Builder getWire();
  inline void setWire( ::Wire::Reader value);
  inline  ::Wire::Builder initWire();
  inline void adoptWire(::capnp::Orphan< ::Wire>&& value);
  inline ::capnp::Orphan< ::Wire> disownWire();

  inline bool isFace();
  inline bool hasFace();
  inline  ::Face::Builder getFace();
  inline void setFace( ::Face::Reader value);
  inline  ::Face::Builder initFace();
  inline void adoptFace(::capnp::Orphan< ::Face>&& value);
  inline ::capnp::Orphan< ::Face> disownFace();

  inline bool isShell();
  inline bool hasShell();
  inline  ::Shell::Builder getShell();
  inline void setShell( ::Shell::Reader value);
  inline  ::Shell::Builder initShell();
  inline void adoptShell(::capnp::Orphan< ::Shell>&& value);
  inline ::capnp::Orphan< ::Shell> disownShell();

  inline bool isSolid();
  inline bool hasSolid();
  inline  ::Solid::Builder getSolid();
  inline void setSolid( ::Solid::Reader value);
  inline  ::Solid::Builder initSolid();
  inline void adoptSolid(::capnp::Orphan< ::Solid>&& value);
  inline ::capnp::Orphan< ::Solid> disownSolid();

  inline bool isCompSolid();
  inline bool hasCompSolid();
  inline  ::CompSolid::Builder getCompSolid();
  inline void setCompSolid( ::CompSolid::Reader value);
  inline  ::CompSolid::Builder initCompSolid();
  inline void adoptCompSolid(::capnp::Orphan< ::CompSolid>&& value);
  inline ::capnp::Orphan< ::CompSolid> disownCompSolid();

  inline bool isCompound();
  inline bool hasCompound();
  inline  ::Compound::Builder getCompound();
  inline void setCompound( ::Compound::Reader value);
  inline  ::Compound::Builder initCompound();
  inline void adoptCompound(::capnp::Orphan< ::Compound>&& value);
  inline ::capnp::Orphan< ::Compound> disownCompound();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Shape::Pipeline {
public:
  typedef Shape Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Vertex::Reader {
public:
  typedef Vertex Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPoint() const;
  inline  ::Vec3::Reader getPoint() const;

  inline double getTolerance() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Vertex::Builder {
public:
  typedef Vertex Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPoint();
  inline  ::Vec3::Builder getPoint();
  inline void setPoint( ::Vec3::Reader value);
  inline  ::Vec3::Builder initPoint();
  inline void adoptPoint(::capnp::Orphan< ::Vec3>&& value);
  inline ::capnp::Orphan< ::Vec3> disownPoint();

  inline double getTolerance();
  inline void setTolerance(double value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Vertex::Pipeline {
public:
  typedef Vertex Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::Vec3::Pipeline getPoint();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Edge::Reader {
public:
  typedef Edge Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasVertices() const;
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader getVertices() const;

  inline bool hasCurve3d() const;
  inline  ::OptionalObjectRef::Reader getCurve3d() const;

  inline double getFirstParameter() const;

  inline double getLastParameter() const;

  inline double getTolerance() const;

  inline bool getDegenerated() const;

  inline bool hasPcurves() const;
  inline  ::capnp::List< ::PCurveOnFace,  ::capnp::Kind::STRUCT>::Reader getPcurves() const;

  inline bool hasPolygon3d() const;
  inline  ::OptionalObjectRef::Reader getPolygon3d() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Edge::Builder {
public:
  typedef Edge Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasVertices();
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder getVertices();
  inline void setVertices( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setVertices(::kj::ArrayPtr<const  ::uint32_t> value);
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder initVertices(unsigned int size);
  inline void adoptVertices(::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> disownVertices();

  inline bool hasCurve3d();
  inline  ::OptionalObjectRef::Builder getCurve3d();
  inline void setCurve3d( ::OptionalObjectRef::Reader value);
  inline  ::OptionalObjectRef::Builder initCurve3d();
  inline void adoptCurve3d(::capnp::Orphan< ::OptionalObjectRef>&& value);
  inline ::capnp::Orphan< ::OptionalObjectRef> disownCurve3d();

  inline double getFirstParameter();
  inline void setFirstParameter(double value);

  inline double getLastParameter();
  inline void setLastParameter(double value);

  inline double getTolerance();
  inline void setTolerance(double value);

  inline bool getDegenerated();
  inline void setDegenerated(bool value);

  inline bool hasPcurves();
  inline  ::capnp::List< ::PCurveOnFace,  ::capnp::Kind::STRUCT>::Builder getPcurves();
  inline void setPcurves( ::capnp::List< ::PCurveOnFace,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::PCurveOnFace,  ::capnp::Kind::STRUCT>::Builder initPcurves(unsigned int size);
  inline void adoptPcurves(::capnp::Orphan< ::capnp::List< ::PCurveOnFace,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::PCurveOnFace,  ::capnp::Kind::STRUCT>> disownPcurves();

  inline bool hasPolygon3d();
  inline  ::OptionalObjectRef::Builder getPolygon3d();
  inline void setPolygon3d( ::OptionalObjectRef::Reader value);
  inline  ::OptionalObjectRef::Builder initPolygon3d();
  inline void adoptPolygon3d(::capnp::Orphan< ::OptionalObjectRef>&& value);
  inline ::capnp::Orphan< ::OptionalObjectRef> disownPolygon3d();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Edge::Pipeline {
public:
  typedef Edge Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::OptionalObjectRef::Pipeline getCurve3d();
  inline  ::OptionalObjectRef::Pipeline getPolygon3d();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class PCurveOnFace::Reader {
public:
  typedef PCurveOnFace Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getFace() const;

  inline bool hasCurve2d() const;
  inline  ::ObjectRef::Reader getCurve2d() const;

  inline bool hasUvRange() const;
  inline  ::UVRange::Reader getUvRange() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class PCurveOnFace::Builder {
public:
  typedef PCurveOnFace Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getFace();
  inline void setFace( ::uint32_t value);

  inline bool hasCurve2d();
  inline  ::ObjectRef::Builder getCurve2d();
  inline void setCurve2d( ::ObjectRef::Reader value);
  inline  ::ObjectRef::Builder initCurve2d();
  inline void adoptCurve2d(::capnp::Orphan< ::ObjectRef>&& value);
  inline ::capnp::Orphan< ::ObjectRef> disownCurve2d();

  inline bool hasUvRange();
  inline  ::UVRange::Builder getUvRange();
  inline void setUvRange( ::UVRange::Reader value);
  inline  ::UVRange::Builder initUvRange();
  inline void adoptUvRange(::capnp::Orphan< ::UVRange>&& value);
  inline ::capnp::Orphan< ::UVRange> disownUvRange();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class PCurveOnFace::Pipeline {
public:
  typedef PCurveOnFace Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::ObjectRef::Pipeline getCurve2d();
  inline  ::UVRange::Pipeline getUvRange();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Wire::Reader {
public:
  typedef Wire Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasEdges() const;
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader getEdges() const;

  inline bool getClosed() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Wire::Builder {
public:
  typedef Wire Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasEdges();
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder getEdges();
  inline void setEdges( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setEdges(::kj::ArrayPtr<const  ::uint32_t> value);
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder initEdges(unsigned int size);
  inline void adoptEdges(::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> disownEdges();

  inline bool getClosed();
  inline void setClosed(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Wire::Pipeline {
public:
  typedef Wire Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Face::Reader {
public:
  typedef Face Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasSurface() const;
  inline  ::ObjectRef::Reader getSurface() const;

  inline bool hasWires() const;
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader getWires() const;

  inline  ::Orientation getOrientation() const;

  inline double getTolerance() const;

  inline bool hasNaturalBounds() const;
  inline  ::UVRange::Reader getNaturalBounds() const;

  inline bool hasTriangulation() const;
  inline  ::OptionalObjectRef::Reader getTriangulation() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Face::Builder {
public:
  typedef Face Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasSurface();
  inline  ::ObjectRef::Builder getSurface();
  inline void setSurface( ::ObjectRef::Reader value);
  inline  ::ObjectRef::Builder initSurface();
  inline void adoptSurface(::capnp::Orphan< ::ObjectRef>&& value);
  inline ::capnp::Orphan< ::ObjectRef> disownSurface();

  inline bool hasWires();
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder getWires();
  inline void setWires( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setWires(::kj::ArrayPtr<const  ::uint32_t> value);
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder initWires(unsigned int size);
  inline void adoptWires(::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> disownWires();

  inline  ::Orientation getOrientation();
  inline void setOrientation( ::Orientation value);

  inline double getTolerance();
  inline void setTolerance(double value);

  inline bool hasNaturalBounds();
  inline  ::UVRange::Builder getNaturalBounds();
  inline void setNaturalBounds( ::UVRange::Reader value);
  inline  ::UVRange::Builder initNaturalBounds();
  inline void adoptNaturalBounds(::capnp::Orphan< ::UVRange>&& value);
  inline ::capnp::Orphan< ::UVRange> disownNaturalBounds();

  inline bool hasTriangulation();
  inline  ::OptionalObjectRef::Builder getTriangulation();
  inline void setTriangulation( ::OptionalObjectRef::Reader value);
  inline  ::OptionalObjectRef::Builder initTriangulation();
  inline void adoptTriangulation(::capnp::Orphan< ::OptionalObjectRef>&& value);
  inline ::capnp::Orphan< ::OptionalObjectRef> disownTriangulation();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Face::Pipeline {
public:
  typedef Face Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::ObjectRef::Pipeline getSurface();
  inline  ::UVRange::Pipeline getNaturalBounds();
  inline  ::OptionalObjectRef::Pipeline getTriangulation();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Shell::Reader {
public:
  typedef Shell Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasFaces() const;
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader getFaces() const;

  inline bool getClosed() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Shell::Builder {
public:
  typedef Shell Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasFaces();
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder getFaces();
  inline void setFaces( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setFaces(::kj::ArrayPtr<const  ::uint32_t> value);
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder initFaces(unsigned int size);
  inline void adoptFaces(::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> disownFaces();

  inline bool getClosed();
  inline void setClosed(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Shell::Pipeline {
public:
  typedef Shell Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Solid::Reader {
public:
  typedef Solid Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasShells() const;
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader getShells() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Solid::Builder {
public:
  typedef Solid Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasShells();
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder getShells();
  inline void setShells( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setShells(::kj::ArrayPtr<const  ::uint32_t> value);
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder initShells(unsigned int size);
  inline void adoptShells(::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> disownShells();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Solid::Pipeline {
public:
  typedef Solid Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class CompSolid::Reader {
public:
  typedef CompSolid Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasSolids() const;
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader getSolids() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class CompSolid::Builder {
public:
  typedef CompSolid Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasSolids();
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder getSolids();
  inline void setSolids( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setSolids(::kj::ArrayPtr<const  ::uint32_t> value);
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder initSolids(unsigned int size);
  inline void adoptSolids(::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> disownSolids();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class CompSolid::Pipeline {
public:
  typedef CompSolid Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Compound::Reader {
public:
  typedef Compound Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasChildren() const;
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader getChildren() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Compound::Builder {
public:
  typedef Compound Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasChildren();
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder getChildren();
  inline void setChildren( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setChildren(::kj::ArrayPtr<const  ::uint32_t> value);
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder initChildren(unsigned int size);
  inline void adoptChildren(::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> disownChildren();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Compound::Pipeline {
public:
  typedef Compound Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TopologyFile::Reader {
public:
  typedef TopologyFile Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasShapes() const;
  inline  ::capnp::List< ::Shape,  ::capnp::Kind::STRUCT>::Reader getShapes() const;

  inline  ::uint32_t getRootShape() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TopologyFile::Builder {
public:
  typedef TopologyFile Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasShapes();
  inline  ::capnp::List< ::Shape,  ::capnp::Kind::STRUCT>::Builder getShapes();
  inline void setShapes( ::capnp::List< ::Shape,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::Shape,  ::capnp::Kind::STRUCT>::Builder initShapes(unsigned int size);
  inline void adoptShapes(::capnp::Orphan< ::capnp::List< ::Shape,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::Shape,  ::capnp::Kind::STRUCT>> disownShapes();

  inline  ::uint32_t getRootShape();
  inline void setRootShape( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TopologyFile::Pipeline {
public:
  typedef TopologyFile Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline  ::Shape::Which Shape::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline  ::Shape::Which Shape::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Shape::Reader::getIndex() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Shape::Builder::getIndex() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Shape::Builder::setIndex( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::ShapeType Shape::Reader::getShapeType() const {
  return _reader.getDataField< ::ShapeType>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::ShapeType Shape::Builder::getShapeType() {
  return _builder.getDataField< ::ShapeType>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Shape::Builder::setShapeType( ::ShapeType value) {
  _builder.setDataField< ::ShapeType>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::Orientation Shape::Reader::getOrientation() const {
  return _reader.getDataField< ::Orientation>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::Orientation Shape::Builder::getOrientation() {
  return _builder.getDataField< ::Orientation>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void Shape::Builder::setOrientation( ::Orientation value) {
  _builder.setDataField< ::Orientation>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline bool Shape::Reader::isVertex() const {
  return which() == Shape::VERTEX;
}
inline bool Shape::Builder::isVertex() {
  return which() == Shape::VERTEX;
}
inline bool Shape::Reader::hasVertex() const {
  if (which() != Shape::VERTEX) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Shape::Builder::hasVertex() {
  if (which() != Shape::VERTEX) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::Vertex::Reader Shape::Reader::getVertex() const {
  KJ_IREQUIRE((which() == Shape::VERTEX),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Vertex>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::Vertex::Builder Shape::Builder::getVertex() {
  KJ_IREQUIRE((which() == Shape::VERTEX),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Vertex>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Shape::Builder::setVertex( ::Vertex::Reader value) {
  _builder.setDataField<Shape::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, Shape::VERTEX);
  ::capnp::_::PointerHelpers< ::Vertex>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::Vertex::Builder Shape::Builder::initVertex() {
  _builder.setDataField<Shape::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, Shape::VERTEX);
  return ::capnp::_::PointerHelpers< ::Vertex>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Shape::Builder::adoptVertex(
    ::capnp::Orphan< ::Vertex>&& value) {
  _builder.setDataField<Shape::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, Shape::VERTEX);
  ::capnp::_::PointerHelpers< ::Vertex>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Vertex> Shape::Builder::disownVertex() {
  KJ_IREQUIRE((which() == Shape::VERTEX),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Vertex>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Shape::Reader::isEdge() const {
  return which() == Shape::EDGE;
}
inline bool Shape::Builder::isEdge() {
  return which() == Shape::EDGE;
}
inline bool Shape::Reader::hasEdge() const {
  if (which() != Shape::EDGE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Shape::Builder::hasEdge() {
  if (which() != Shape::EDGE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::Edge::Reader Shape::Reader::getEdge() const {
  KJ_IREQUIRE((which() == Shape::EDGE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Edge>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::Edge::Builder Shape::Builder::getEdge() {
  KJ_IREQUIRE((which() == Shape::EDGE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Edge>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Shape::Builder::setEdge( ::Edge::Reader value) {
  _builder.setDataField<Shape::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, Shape::EDGE);
  ::capnp::_::PointerHelpers< ::Edge>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::Edge::Builder Shape::Builder::initEdge() {
  _builder.setDataField<Shape::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, Shape::EDGE);
  return ::capnp::_::PointerHelpers< ::Edge>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Shape::Builder::adoptEdge(
    ::capnp::Orphan< ::Edge>&& value) {
  _builder.setDataField<Shape::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, Shape::EDGE);
  ::capnp::_::PointerHelpers< ::Edge>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Edge> Shape::Builder::disownEdge() {
  KJ_IREQUIRE((which() == Shape::EDGE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Edge>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Shape::Reader::isWire() const {
  return which() == Shape::WIRE;
}
inline bool Shape::Builder::isWire() {
  return which() == Shape::WIRE;
}
inline bool Shape::Reader::hasWire() const {
  if (which() != Shape::WIRE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Shape::Builder::hasWire() {
  if (which() != Shape::WIRE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::Wire::Reader Shape::Reader::getWire() const {
  KJ_IREQUIRE((which() == Shape::WIRE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Wire>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::Wire::Builder Shape::Builder::getWire() {
  KJ_IREQUIRE((which() == Shape::WIRE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Wire>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Shape::Builder::setWire( ::Wire::Reader value) {
  _builder.setDataField<Shape::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, Shape::WIRE);
  ::capnp::_::PointerHelpers< ::Wire>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::Wire::Builder Shape::Builder::initWire() {
  _builder.setDataField<Shape::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, Shape::WIRE);
  return ::capnp::_::PointerHelpers< ::Wire>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Shape::Builder::adoptWire(
    ::capnp::Orphan< ::Wire>&& value) {
  _builder.setDataField<Shape::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, Shape::WIRE);
  ::capnp::_::PointerHelpers< ::Wire>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Wire> Shape::Builder::disownWire() {
  KJ_IREQUIRE((which() == Shape::WIRE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Wire>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Shape::Reader::isFace() const {
  return which() == Shape::FACE;
}
inline bool Shape::Builder::isFace() {
  return which() == Shape::FACE;
}
inline bool Shape::Reader::hasFace() const {
  if (which() != Shape::FACE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Shape::Builder::hasFace() {
  if (which() != Shape::FACE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::Face::Reader Shape::Reader::getFace() const {
  KJ_IREQUIRE((which() == Shape::FACE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Face>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::Face::Builder Shape::Builder::getFace() {
  KJ_IREQUIRE((which() == Shape::FACE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Face>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Shape::Builder::setFace( ::Face::Reader value) {
  _builder.setDataField<Shape::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, Shape::FACE);
  ::capnp::_::PointerHelpers< ::Face>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::Face::Builder Shape::Builder::initFace() {
  _builder.setDataField<Shape::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, Shape::FACE);
  return ::capnp::_::PointerHelpers< ::Face>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Shape::Builder::adoptFace(
    ::capnp::Orphan< ::Face>&& value) {
  _builder.setDataField<Shape::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, Shape::FACE);
  ::capnp::_::PointerHelpers< ::Face>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Face> Shape::Builder::disownFace() {
  KJ_IREQUIRE((which() == Shape::FACE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Face>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Shape::Reader::isShell() const {
  return which() == Shape::SHELL;
}
inline bool Shape::Builder::isShell() {
  return which() == Shape::SHELL;
}
inline bool Shape::Reader::hasShell() const {
  if (which() != Shape::SHELL) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Shape::Builder::hasShell() {
  if (which() != Shape::SHELL) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::Shell::Reader Shape::Reader::getShell() const {
  KJ_IREQUIRE((which() == Shape::SHELL),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Shell>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::Shell::Builder Shape::Builder::getShell() {
  KJ_IREQUIRE((which() == Shape::SHELL),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Shell>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Shape::Builder::setShell( ::Shell::Reader value) {
  _builder.setDataField<Shape::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, Shape::SHELL);
  ::capnp::_::PointerHelpers< ::Shell>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::Shell::Builder Shape::Builder::initShell() {
  _builder.setDataField<Shape::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, Shape::SHELL);
  return ::capnp::_::PointerHelpers< ::Shell>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Shape::Builder::adoptShell(
    ::capnp::Orphan< ::Shell>&& value) {
  _builder.setDataField<Shape::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, Shape::SHELL);
  ::capnp::_::PointerHelpers< ::Shell>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Shell> Shape::Builder::disownShell() {
  KJ_IREQUIRE((which() == Shape::SHELL),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Shell>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Shape::Reader::isSolid() const {
  return which() == Shape::SOLID;
}
inline bool Shape::Builder::isSolid() {
  return which() == Shape::SOLID;
}
inline bool Shape::Reader::hasSolid() const {
  if (which() != Shape::SOLID) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Shape::Builder::hasSolid() {
  if (which() != Shape::SOLID) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::Solid::Reader Shape::Reader::getSolid() const {
  KJ_IREQUIRE((which() == Shape::SOLID),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Solid>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::Solid::Builder Shape::Builder::getSolid() {
  KJ_IREQUIRE((which() == Shape::SOLID),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Solid>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Shape::Builder::setSolid( ::Solid::Reader value) {
  _builder.setDataField<Shape::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, Shape::SOLID);
  ::capnp::_::PointerHelpers< ::Solid>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::Solid::Builder Shape::Builder::initSolid() {
  _builder.setDataField<Shape::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, Shape::SOLID);
  return ::capnp::_::PointerHelpers< ::Solid>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Shape::Builder::adoptSolid(
    ::capnp::Orphan< ::Solid>&& value) {
  _builder.setDataField<Shape::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, Shape::SOLID);
  ::capnp::_::PointerHelpers< ::Solid>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Solid> Shape::Builder::disownSolid() {
  KJ_IREQUIRE((which() == Shape::SOLID),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Solid>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Shape::Reader::isCompSolid() const {
  return which() == Shape::COMP_SOLID;
}
inline bool Shape::Builder::isCompSolid() {
  return which() == Shape::COMP_SOLID;
}
inline bool Shape::Reader::hasCompSolid() const {
  if (which() != Shape::COMP_SOLID) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Shape::Builder::hasCompSolid() {
  if (which() != Shape::COMP_SOLID) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::CompSolid::Reader Shape::Reader::getCompSolid() const {
  KJ_IREQUIRE((which() == Shape::COMP_SOLID),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::CompSolid>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::CompSolid::Builder Shape::Builder::getCompSolid() {
  KJ_IREQUIRE((which() == Shape::COMP_SOLID),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::CompSolid>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Shape::Builder::setCompSolid( ::CompSolid::Reader value) {
  _builder.setDataField<Shape::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, Shape::COMP_SOLID);
  ::capnp::_::PointerHelpers< ::CompSolid>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::CompSolid::Builder Shape::Builder::initCompSolid() {
  _builder.setDataField<Shape::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, Shape::COMP_SOLID);
  return ::capnp::_::PointerHelpers< ::CompSolid>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Shape::Builder::adoptCompSolid(
    ::capnp::Orphan< ::CompSolid>&& value) {
  _builder.setDataField<Shape::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, Shape::COMP_SOLID);
  ::capnp::_::PointerHelpers< ::CompSolid>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::CompSolid> Shape::Builder::disownCompSolid() {
  KJ_IREQUIRE((which() == Shape::COMP_SOLID),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::CompSolid>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Shape::Reader::isCompound() const {
  return which() == Shape::COMPOUND;
}
inline bool Shape::Builder::isCompound() {
  return which() == Shape::COMPOUND;
}
inline bool Shape::Reader::hasCompound() const {
  if (which() != Shape::COMPOUND) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Shape::Builder::hasCompound() {
  if (which() != Shape::COMPOUND) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::Compound::Reader Shape::Reader::getCompound() const {
  KJ_IREQUIRE((which() == Shape::COMPOUND),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Compound>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::Compound::Builder Shape::Builder::getCompound() {
  KJ_IREQUIRE((which() == Shape::COMPOUND),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Compound>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Shape::Builder::setCompound( ::Compound::Reader value) {
  _builder.setDataField<Shape::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, Shape::COMPOUND);
  ::capnp::_::PointerHelpers< ::Compound>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::Compound::Builder Shape::Builder::initCompound() {
  _builder.setDataField<Shape::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, Shape::COMPOUND);
  return ::capnp::_::PointerHelpers< ::Compound>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Shape::Builder::adoptCompound(
    ::capnp::Orphan< ::Compound>&& value) {
  _builder.setDataField<Shape::Which>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, Shape::COMPOUND);
  ::capnp::_::PointerHelpers< ::Compound>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Compound> Shape::Builder::disownCompound() {
  KJ_IREQUIRE((which() == Shape::COMPOUND),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Compound>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Vertex::Reader::hasPoint() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Vertex::Builder::hasPoint() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::Vec3::Reader Vertex::Reader::getPoint() const {
  return ::capnp::_::PointerHelpers< ::Vec3>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::Vec3::Builder Vertex::Builder::getPoint() {
  return ::capnp::_::PointerHelpers< ::Vec3>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Vec3::Pipeline Vertex::Pipeline::getPoint() {
  return  ::Vec3::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Vertex::Builder::setPoint( ::Vec3::Reader value) {
  ::capnp::_::PointerHelpers< ::Vec3>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::Vec3::Builder Vertex::Builder::initPoint() {
  return ::capnp::_::PointerHelpers< ::Vec3>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Vertex::Builder::adoptPoint(
    ::capnp::Orphan< ::Vec3>&& value) {
  ::capnp::_::PointerHelpers< ::Vec3>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Vec3> Vertex::Builder::disownPoint() {
  return ::capnp::_::PointerHelpers< ::Vec3>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline double Vertex::Reader::getTolerance() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline double Vertex::Builder::getTolerance() {
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Vertex::Builder::setTolerance(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Edge::Reader::hasVertices() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Edge::Builder::hasVertices() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader Edge::Reader::getVertices() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder Edge::Builder::getVertices() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Edge::Builder::setVertices( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void Edge::Builder::setVertices(::kj::ArrayPtr<const  ::uint32_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder Edge::Builder::initVertices(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Edge::Builder::adoptVertices(
    ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> Edge::Builder::disownVertices() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Edge::Reader::hasCurve3d() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Edge::Builder::hasCurve3d() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::OptionalObjectRef::Reader Edge::Reader::getCurve3d() const {
  return ::capnp::_::PointerHelpers< ::OptionalObjectRef>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::OptionalObjectRef::Builder Edge::Builder::getCurve3d() {
  return ::capnp::_::PointerHelpers< ::OptionalObjectRef>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::OptionalObjectRef::Pipeline Edge::Pipeline::getCurve3d() {
  return  ::OptionalObjectRef::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Edge::Builder::setCurve3d( ::OptionalObjectRef::Reader value) {
  ::capnp::_::PointerHelpers< ::OptionalObjectRef>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::OptionalObjectRef::Builder Edge::Builder::initCurve3d() {
  return ::capnp::_::PointerHelpers< ::OptionalObjectRef>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Edge::Builder::adoptCurve3d(
    ::capnp::Orphan< ::OptionalObjectRef>&& value) {
  ::capnp::_::PointerHelpers< ::OptionalObjectRef>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::OptionalObjectRef> Edge::Builder::disownCurve3d() {
  return ::capnp::_::PointerHelpers< ::OptionalObjectRef>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline double Edge::Reader::getFirstParameter() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline double Edge::Builder::getFirstParameter() {
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Edge::Builder::setFirstParameter(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline double Edge::Reader::getLastParameter() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline double Edge::Builder::getLastParameter() {
  return _builder.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Edge::Builder::setLastParameter(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline double Edge::Reader::getTolerance() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline double Edge::Builder::getTolerance() {
  return _builder.getDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Edge::Builder::setTolerance(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool Edge::Reader::getDegenerated() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<192>() * ::capnp::ELEMENTS);
}

inline bool Edge::Builder::getDegenerated() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<192>() * ::capnp::ELEMENTS);
}
inline void Edge::Builder::setDegenerated(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<192>() * ::capnp::ELEMENTS, value);
}

inline bool Edge::Reader::hasPcurves() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Edge::Builder::hasPcurves() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::PCurveOnFace,  ::capnp::Kind::STRUCT>::Reader Edge::Reader::getPcurves() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::PCurveOnFace,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::PCurveOnFace,  ::capnp::Kind::STRUCT>::Builder Edge::Builder::getPcurves() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::PCurveOnFace,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Edge::Builder::setPcurves( ::capnp::List< ::PCurveOnFace,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::PCurveOnFace,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::PCurveOnFace,  ::capnp::Kind::STRUCT>::Builder Edge::Builder::initPcurves(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::PCurveOnFace,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void Edge::Builder::adoptPcurves(
    ::capnp::Orphan< ::capnp::List< ::PCurveOnFace,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::PCurveOnFace,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::PCurveOnFace,  ::capnp::Kind::STRUCT>> Edge::Builder::disownPcurves() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::PCurveOnFace,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Edge::Reader::hasPolygon3d() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool Edge::Builder::hasPolygon3d() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::OptionalObjectRef::Reader Edge::Reader::getPolygon3d() const {
  return ::capnp::_::PointerHelpers< ::OptionalObjectRef>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::OptionalObjectRef::Builder Edge::Builder::getPolygon3d() {
  return ::capnp::_::PointerHelpers< ::OptionalObjectRef>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::OptionalObjectRef::Pipeline Edge::Pipeline::getPolygon3d() {
  return  ::OptionalObjectRef::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void Edge::Builder::setPolygon3d( ::OptionalObjectRef::Reader value) {
  ::capnp::_::PointerHelpers< ::OptionalObjectRef>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::OptionalObjectRef::Builder Edge::Builder::initPolygon3d() {
  return ::capnp::_::PointerHelpers< ::OptionalObjectRef>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Edge::Builder::adoptPolygon3d(
    ::capnp::Orphan< ::OptionalObjectRef>&& value) {
  ::capnp::_::PointerHelpers< ::OptionalObjectRef>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::OptionalObjectRef> Edge::Builder::disownPolygon3d() {
  return ::capnp::_::PointerHelpers< ::OptionalObjectRef>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline  ::uint32_t PCurveOnFace::Reader::getFace() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t PCurveOnFace::Builder::getFace() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void PCurveOnFace::Builder::setFace( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool PCurveOnFace::Reader::hasCurve2d() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool PCurveOnFace::Builder::hasCurve2d() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::ObjectRef::Reader PCurveOnFace::Reader::getCurve2d() const {
  return ::capnp::_::PointerHelpers< ::ObjectRef>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::ObjectRef::Builder PCurveOnFace::Builder::getCurve2d() {
  return ::capnp::_::PointerHelpers< ::ObjectRef>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::ObjectRef::Pipeline PCurveOnFace::Pipeline::getCurve2d() {
  return  ::ObjectRef::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void PCurveOnFace::Builder::setCurve2d( ::ObjectRef::Reader value) {
  ::capnp::_::PointerHelpers< ::ObjectRef>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::ObjectRef::Builder PCurveOnFace::Builder::initCurve2d() {
  return ::capnp::_::PointerHelpers< ::ObjectRef>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void PCurveOnFace::Builder::adoptCurve2d(
    ::capnp::Orphan< ::ObjectRef>&& value) {
  ::capnp::_::PointerHelpers< ::ObjectRef>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::ObjectRef> PCurveOnFace::Builder::disownCurve2d() {
  return ::capnp::_::PointerHelpers< ::ObjectRef>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool PCurveOnFace::Reader::hasUvRange() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool PCurveOnFace::Builder::hasUvRange() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::UVRange::Reader PCurveOnFace::Reader::getUvRange() const {
  return ::capnp::_::PointerHelpers< ::UVRange>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::UVRange::Builder PCurveOnFace::Builder::getUvRange() {
  return ::capnp::_::PointerHelpers< ::UVRange>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::UVRange::Pipeline PCurveOnFace::Pipeline::getUvRange() {
  return  ::UVRange::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void PCurveOnFace::Builder::setUvRange( ::UVRange::Reader value) {
  ::capnp::_::PointerHelpers< ::UVRange>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::UVRange::Builder PCurveOnFace::Builder::initUvRange() {
  return ::capnp::_::PointerHelpers< ::UVRange>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void PCurveOnFace::Builder::adoptUvRange(
    ::capnp::Orphan< ::UVRange>&& value) {
  ::capnp::_::PointerHelpers< ::UVRange>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::UVRange> PCurveOnFace::Builder::disownUvRange() {
  return ::capnp::_::PointerHelpers< ::UVRange>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Wire::Reader::hasEdges() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Wire::Builder::hasEdges() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader Wire::Reader::getEdges() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder Wire::Builder::getEdges() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Wire::Builder::setEdges( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void Wire::Builder::setEdges(::kj::ArrayPtr<const  ::uint32_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder Wire::Builder::initEdges(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Wire::Builder::adoptEdges(
    ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> Wire::Builder::disownEdges() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Wire::Reader::getClosed() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Wire::Builder::getClosed() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Wire::Builder::setClosed(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Face::Reader::hasSurface() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Face::Builder::hasSurface() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::ObjectRef::Reader Face::Reader::getSurface() const {
  return ::capnp::_::PointerHelpers< ::ObjectRef>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::ObjectRef::Builder Face::Builder::getSurface() {
  return ::capnp::_::PointerHelpers< ::ObjectRef>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::ObjectRef::Pipeline Face::Pipeline::getSurface() {
  return  ::ObjectRef::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Face::Builder::setSurface( ::ObjectRef::Reader value) {
  ::capnp::_::PointerHelpers< ::ObjectRef>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::ObjectRef::Builder Face::Builder::initSurface() {
  return ::capnp::_::PointerHelpers< ::ObjectRef>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Face::Builder::adoptSurface(
    ::capnp::Orphan< ::ObjectRef>&& value) {
  ::capnp::_::PointerHelpers< ::ObjectRef>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::ObjectRef> Face::Builder::disownSurface() {
  return ::capnp::_::PointerHelpers< ::ObjectRef>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Face::Reader::hasWires() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Face::Builder::hasWires() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader Face::Reader::getWires() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder Face::Builder::getWires() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Face::Builder::setWires( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline void Face::Builder::setWires(::kj::ArrayPtr<const  ::uint32_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder Face::Builder::initWires(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Face::Builder::adoptWires(
    ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> Face::Builder::disownWires() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::Orientation Face::Reader::getOrientation() const {
  return _reader.getDataField< ::Orientation>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::Orientation Face::Builder::getOrientation() {
  return _builder.getDataField< ::Orientation>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Face::Builder::setOrientation( ::Orientation value) {
  _builder.setDataField< ::Orientation>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline double Face::Reader::getTolerance() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline double Face::Builder::getTolerance() {
  return _builder.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Face::Builder::setTolerance(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Face::Reader::hasNaturalBounds() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Face::Builder::hasNaturalBounds() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::UVRange::Reader Face::Reader::getNaturalBounds() const {
  return ::capnp::_::PointerHelpers< ::UVRange>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::UVRange::Builder Face::Builder::getNaturalBounds() {
  return ::capnp::_::PointerHelpers< ::UVRange>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::UVRange::Pipeline Face::Pipeline::getNaturalBounds() {
  return  ::UVRange::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void Face::Builder::setNaturalBounds( ::UVRange::Reader value) {
  ::capnp::_::PointerHelpers< ::UVRange>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::UVRange::Builder Face::Builder::initNaturalBounds() {
  return ::capnp::_::PointerHelpers< ::UVRange>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Face::Builder::adoptNaturalBounds(
    ::capnp::Orphan< ::UVRange>&& value) {
  ::capnp::_::PointerHelpers< ::UVRange>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::UVRange> Face::Builder::disownNaturalBounds() {
  return ::capnp::_::PointerHelpers< ::UVRange>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Face::Reader::hasTriangulation() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool Face::Builder::hasTriangulation() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::OptionalObjectRef::Reader Face::Reader::getTriangulation() const {
  return ::capnp::_::PointerHelpers< ::OptionalObjectRef>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::OptionalObjectRef::Builder Face::Builder::getTriangulation() {
  return ::capnp::_::PointerHelpers< ::OptionalObjectRef>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::OptionalObjectRef::Pipeline Face::Pipeline::getTriangulation() {
  return  ::OptionalObjectRef::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void Face::Builder::setTriangulation( ::OptionalObjectRef::Reader value) {
  ::capnp::_::PointerHelpers< ::OptionalObjectRef>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::OptionalObjectRef::Builder Face::Builder::initTriangulation() {
  return ::capnp::_::PointerHelpers< ::OptionalObjectRef>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Face::Builder::adoptTriangulation(
    ::capnp::Orphan< ::OptionalObjectRef>&& value) {
  ::capnp::_::PointerHelpers< ::OptionalObjectRef>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::OptionalObjectRef> Face::Builder::disownTriangulation() {
  return ::capnp::_::PointerHelpers< ::OptionalObjectRef>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool Shell::Reader::hasFaces() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Shell::Builder::hasFaces() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader Shell::Reader::getFaces() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder Shell::Builder::getFaces() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Shell::Builder::setFaces( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void Shell::Builder::setFaces(::kj::ArrayPtr<const  ::uint32_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder Shell::Builder::initFaces(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Shell::Builder::adoptFaces(
    ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> Shell::Builder::disownFaces() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Shell::Reader::getClosed() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Shell::Builder::getClosed() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Shell::Builder::setClosed(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Solid::Reader::hasShells() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Solid::Builder::hasShells() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader Solid::Reader::getShells() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder Solid::Builder::getShells() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Solid::Builder::setShells( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void Solid::Builder::setShells(::kj::ArrayPtr<const  ::uint32_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder Solid::Builder::initShells(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Solid::Builder::adoptShells(
    ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> Solid::Builder::disownShells() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool CompSolid::Reader::hasSolids() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool CompSolid::Builder::hasSolids() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader CompSolid::Reader::getSolids() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder CompSolid::Builder::getSolids() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void CompSolid::Builder::setSolids( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void CompSolid::Builder::setSolids(::kj::ArrayPtr<const  ::uint32_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder CompSolid::Builder::initSolids(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void CompSolid::Builder::adoptSolids(
    ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> CompSolid::Builder::disownSolids() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Compound::Reader::hasChildren() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Compound::Builder::hasChildren() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader Compound::Reader::getChildren() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder Compound::Builder::getChildren() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Compound::Builder::setChildren( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void Compound::Builder::setChildren(::kj::ArrayPtr<const  ::uint32_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder Compound::Builder::initChildren(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Compound::Builder::adoptChildren(
    ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> Compound::Builder::disownChildren() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool TopologyFile::Reader::hasShapes() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TopologyFile::Builder::hasShapes() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::Shape,  ::capnp::Kind::STRUCT>::Reader TopologyFile::Reader::getShapes() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Shape,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::Shape,  ::capnp::Kind::STRUCT>::Builder TopologyFile::Builder::getShapes() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Shape,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TopologyFile::Builder::setShapes( ::capnp::List< ::Shape,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Shape,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::Shape,  ::capnp::Kind::STRUCT>::Builder TopologyFile::Builder::initShapes(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Shape,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TopologyFile::Builder::adoptShapes(
    ::capnp::Orphan< ::capnp::List< ::Shape,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Shape,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::Shape,  ::capnp::Kind::STRUCT>> TopologyFile::Builder::disownShapes() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Shape,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint32_t TopologyFile::Reader::getRootShape() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t TopologyFile::Builder::getRootShape() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TopologyFile::Builder::setRootShape( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}


CAPNP_END_HEADER

