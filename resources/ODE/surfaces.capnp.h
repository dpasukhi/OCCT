// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: surfaces.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>

#ifndef CAPNP_VERSION
#error "CAPNP_VERSION is not defined, is capnp/generated-header-support.h missing?"
#elif CAPNP_VERSION != 1002000
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif

#include "ode.capnp.h"

CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(ac99a1035aafc87d);
CAPNP_DECLARE_SCHEMA(ea65f19e04137941);
CAPNP_DECLARE_SCHEMA(e85ead069701ba91);
CAPNP_DECLARE_SCHEMA(b3217699535d7b9a);
CAPNP_DECLARE_SCHEMA(f09a81232199d669);
CAPNP_DECLARE_SCHEMA(a29dcb4175694139);
CAPNP_DECLARE_SCHEMA(b8f1522dd7130646);
CAPNP_DECLARE_SCHEMA(e5a8acab5bf64dd6);
CAPNP_DECLARE_SCHEMA(8b93176f10156209);
CAPNP_DECLARE_SCHEMA(8e160cc2f1dc0f7b);
CAPNP_DECLARE_SCHEMA(b134a4220c0d4c5f);
CAPNP_DECLARE_SCHEMA(83c622e2426b4921);
CAPNP_DECLARE_SCHEMA(aba5611a2d25a2a7);

}  // namespace schemas
}  // namespace capnp


struct Surface {
  Surface() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    PLANE,
    CYLINDRICAL_SURFACE,
    CONICAL_SURFACE,
    SPHERICAL_SURFACE,
    TOROIDAL_SURFACE,
    SURFACE_OF_REVOLUTION,
    SURFACE_OF_LINEAR_EXTRUSION,
    BEZIER_SURFACE,
    BSPLINE_SURFACE,
    RECTANGULAR_TRIMMED_SURFACE,
    OFFSET_SURFACE,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ac99a1035aafc87d, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Plane {
  Plane() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ea65f19e04137941, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct CylindricalSurface {
  CylindricalSurface() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e85ead069701ba91, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ConicalSurface {
  ConicalSurface() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b3217699535d7b9a, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct SphericalSurface {
  SphericalSurface() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f09a81232199d669, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ToroidalSurface {
  ToroidalSurface() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a29dcb4175694139, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct SurfaceOfRevolution {
  SurfaceOfRevolution() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b8f1522dd7130646, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct SurfaceOfLinearExtrusion {
  SurfaceOfLinearExtrusion() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e5a8acab5bf64dd6, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct BezierSurface {
  BezierSurface() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8b93176f10156209, 2, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct BSplineSurface {
  BSplineSurface() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8e160cc2f1dc0f7b, 2, 6)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct RectangularTrimmedSurface {
  RectangularTrimmedSurface() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b134a4220c0d4c5f, 5, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct OffsetSurface {
  OffsetSurface() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(83c622e2426b4921, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct SurfaceFile {
  SurfaceFile() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(aba5611a2d25a2a7, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class Surface::Reader {
public:
  typedef Surface Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline  ::uint32_t getIndex() const;

  inline bool isPlane() const;
  inline bool hasPlane() const;
  inline  ::Plane::Reader getPlane() const;

  inline bool isCylindricalSurface() const;
  inline bool hasCylindricalSurface() const;
  inline  ::CylindricalSurface::Reader getCylindricalSurface() const;

  inline bool isConicalSurface() const;
  inline bool hasConicalSurface() const;
  inline  ::ConicalSurface::Reader getConicalSurface() const;

  inline bool isSphericalSurface() const;
  inline bool hasSphericalSurface() const;
  inline  ::SphericalSurface::Reader getSphericalSurface() const;

  inline bool isToroidalSurface() const;
  inline bool hasToroidalSurface() const;
  inline  ::ToroidalSurface::Reader getToroidalSurface() const;

  inline bool isSurfaceOfRevolution() const;
  inline bool hasSurfaceOfRevolution() const;
  inline  ::SurfaceOfRevolution::Reader getSurfaceOfRevolution() const;

  inline bool isSurfaceOfLinearExtrusion() const;
  inline bool hasSurfaceOfLinearExtrusion() const;
  inline  ::SurfaceOfLinearExtrusion::Reader getSurfaceOfLinearExtrusion() const;

  inline bool isBezierSurface() const;
  inline bool hasBezierSurface() const;
  inline  ::BezierSurface::Reader getBezierSurface() const;

  inline bool isBsplineSurface() const;
  inline bool hasBsplineSurface() const;
  inline  ::BSplineSurface::Reader getBsplineSurface() const;

  inline bool isRectangularTrimmedSurface() const;
  inline bool hasRectangularTrimmedSurface() const;
  inline  ::RectangularTrimmedSurface::Reader getRectangularTrimmedSurface() const;

  inline bool isOffsetSurface() const;
  inline bool hasOffsetSurface() const;
  inline  ::OffsetSurface::Reader getOffsetSurface() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Surface::Builder {
public:
  typedef Surface Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline  ::uint32_t getIndex();
  inline void setIndex( ::uint32_t value);

  inline bool isPlane();
  inline bool hasPlane();
  inline  ::Plane::Builder getPlane();
  inline void setPlane( ::Plane::Reader value);
  inline  ::Plane::Builder initPlane();
  inline void adoptPlane(::capnp::Orphan< ::Plane>&& value);
  inline ::capnp::Orphan< ::Plane> disownPlane();

  inline bool isCylindricalSurface();
  inline bool hasCylindricalSurface();
  inline  ::CylindricalSurface::Builder getCylindricalSurface();
  inline void setCylindricalSurface( ::CylindricalSurface::Reader value);
  inline  ::CylindricalSurface::Builder initCylindricalSurface();
  inline void adoptCylindricalSurface(::capnp::Orphan< ::CylindricalSurface>&& value);
  inline ::capnp::Orphan< ::CylindricalSurface> disownCylindricalSurface();

  inline bool isConicalSurface();
  inline bool hasConicalSurface();
  inline  ::ConicalSurface::Builder getConicalSurface();
  inline void setConicalSurface( ::ConicalSurface::Reader value);
  inline  ::ConicalSurface::Builder initConicalSurface();
  inline void adoptConicalSurface(::capnp::Orphan< ::ConicalSurface>&& value);
  inline ::capnp::Orphan< ::ConicalSurface> disownConicalSurface();

  inline bool isSphericalSurface();
  inline bool hasSphericalSurface();
  inline  ::SphericalSurface::Builder getSphericalSurface();
  inline void setSphericalSurface( ::SphericalSurface::Reader value);
  inline  ::SphericalSurface::Builder initSphericalSurface();
  inline void adoptSphericalSurface(::capnp::Orphan< ::SphericalSurface>&& value);
  inline ::capnp::Orphan< ::SphericalSurface> disownSphericalSurface();

  inline bool isToroidalSurface();
  inline bool hasToroidalSurface();
  inline  ::ToroidalSurface::Builder getToroidalSurface();
  inline void setToroidalSurface( ::ToroidalSurface::Reader value);
  inline  ::ToroidalSurface::Builder initToroidalSurface();
  inline void adoptToroidalSurface(::capnp::Orphan< ::ToroidalSurface>&& value);
  inline ::capnp::Orphan< ::ToroidalSurface> disownToroidalSurface();

  inline bool isSurfaceOfRevolution();
  inline bool hasSurfaceOfRevolution();
  inline  ::SurfaceOfRevolution::Builder getSurfaceOfRevolution();
  inline void setSurfaceOfRevolution( ::SurfaceOfRevolution::Reader value);
  inline  ::SurfaceOfRevolution::Builder initSurfaceOfRevolution();
  inline void adoptSurfaceOfRevolution(::capnp::Orphan< ::SurfaceOfRevolution>&& value);
  inline ::capnp::Orphan< ::SurfaceOfRevolution> disownSurfaceOfRevolution();

  inline bool isSurfaceOfLinearExtrusion();
  inline bool hasSurfaceOfLinearExtrusion();
  inline  ::SurfaceOfLinearExtrusion::Builder getSurfaceOfLinearExtrusion();
  inline void setSurfaceOfLinearExtrusion( ::SurfaceOfLinearExtrusion::Reader value);
  inline  ::SurfaceOfLinearExtrusion::Builder initSurfaceOfLinearExtrusion();
  inline void adoptSurfaceOfLinearExtrusion(::capnp::Orphan< ::SurfaceOfLinearExtrusion>&& value);
  inline ::capnp::Orphan< ::SurfaceOfLinearExtrusion> disownSurfaceOfLinearExtrusion();

  inline bool isBezierSurface();
  inline bool hasBezierSurface();
  inline  ::BezierSurface::Builder getBezierSurface();
  inline void setBezierSurface( ::BezierSurface::Reader value);
  inline  ::BezierSurface::Builder initBezierSurface();
  inline void adoptBezierSurface(::capnp::Orphan< ::BezierSurface>&& value);
  inline ::capnp::Orphan< ::BezierSurface> disownBezierSurface();

  inline bool isBsplineSurface();
  inline bool hasBsplineSurface();
  inline  ::BSplineSurface::Builder getBsplineSurface();
  inline void setBsplineSurface( ::BSplineSurface::Reader value);
  inline  ::BSplineSurface::Builder initBsplineSurface();
  inline void adoptBsplineSurface(::capnp::Orphan< ::BSplineSurface>&& value);
  inline ::capnp::Orphan< ::BSplineSurface> disownBsplineSurface();

  inline bool isRectangularTrimmedSurface();
  inline bool hasRectangularTrimmedSurface();
  inline  ::RectangularTrimmedSurface::Builder getRectangularTrimmedSurface();
  inline void setRectangularTrimmedSurface( ::RectangularTrimmedSurface::Reader value);
  inline  ::RectangularTrimmedSurface::Builder initRectangularTrimmedSurface();
  inline void adoptRectangularTrimmedSurface(::capnp::Orphan< ::RectangularTrimmedSurface>&& value);
  inline ::capnp::Orphan< ::RectangularTrimmedSurface> disownRectangularTrimmedSurface();

  inline bool isOffsetSurface();
  inline bool hasOffsetSurface();
  inline  ::OffsetSurface::Builder getOffsetSurface();
  inline void setOffsetSurface( ::OffsetSurface::Reader value);
  inline  ::OffsetSurface::Builder initOffsetSurface();
  inline void adoptOffsetSurface(::capnp::Orphan< ::OffsetSurface>&& value);
  inline ::capnp::Orphan< ::OffsetSurface> disownOffsetSurface();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Surface::Pipeline {
public:
  typedef Surface Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Plane::Reader {
public:
  typedef Plane Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPosition() const;
  inline  ::AxisPlacement::Reader getPosition() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Plane::Builder {
public:
  typedef Plane Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPosition();
  inline  ::AxisPlacement::Builder getPosition();
  inline void setPosition( ::AxisPlacement::Reader value);
  inline  ::AxisPlacement::Builder initPosition();
  inline void adoptPosition(::capnp::Orphan< ::AxisPlacement>&& value);
  inline ::capnp::Orphan< ::AxisPlacement> disownPosition();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Plane::Pipeline {
public:
  typedef Plane Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::AxisPlacement::Pipeline getPosition();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class CylindricalSurface::Reader {
public:
  typedef CylindricalSurface Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPosition() const;
  inline  ::AxisPlacement::Reader getPosition() const;

  inline double getRadius() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class CylindricalSurface::Builder {
public:
  typedef CylindricalSurface Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPosition();
  inline  ::AxisPlacement::Builder getPosition();
  inline void setPosition( ::AxisPlacement::Reader value);
  inline  ::AxisPlacement::Builder initPosition();
  inline void adoptPosition(::capnp::Orphan< ::AxisPlacement>&& value);
  inline ::capnp::Orphan< ::AxisPlacement> disownPosition();

  inline double getRadius();
  inline void setRadius(double value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class CylindricalSurface::Pipeline {
public:
  typedef CylindricalSurface Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::AxisPlacement::Pipeline getPosition();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ConicalSurface::Reader {
public:
  typedef ConicalSurface Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPosition() const;
  inline  ::AxisPlacement::Reader getPosition() const;

  inline double getRadius() const;

  inline double getSemiAngle() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ConicalSurface::Builder {
public:
  typedef ConicalSurface Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPosition();
  inline  ::AxisPlacement::Builder getPosition();
  inline void setPosition( ::AxisPlacement::Reader value);
  inline  ::AxisPlacement::Builder initPosition();
  inline void adoptPosition(::capnp::Orphan< ::AxisPlacement>&& value);
  inline ::capnp::Orphan< ::AxisPlacement> disownPosition();

  inline double getRadius();
  inline void setRadius(double value);

  inline double getSemiAngle();
  inline void setSemiAngle(double value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ConicalSurface::Pipeline {
public:
  typedef ConicalSurface Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::AxisPlacement::Pipeline getPosition();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class SphericalSurface::Reader {
public:
  typedef SphericalSurface Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPosition() const;
  inline  ::AxisPlacement::Reader getPosition() const;

  inline double getRadius() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class SphericalSurface::Builder {
public:
  typedef SphericalSurface Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPosition();
  inline  ::AxisPlacement::Builder getPosition();
  inline void setPosition( ::AxisPlacement::Reader value);
  inline  ::AxisPlacement::Builder initPosition();
  inline void adoptPosition(::capnp::Orphan< ::AxisPlacement>&& value);
  inline ::capnp::Orphan< ::AxisPlacement> disownPosition();

  inline double getRadius();
  inline void setRadius(double value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class SphericalSurface::Pipeline {
public:
  typedef SphericalSurface Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::AxisPlacement::Pipeline getPosition();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ToroidalSurface::Reader {
public:
  typedef ToroidalSurface Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPosition() const;
  inline  ::AxisPlacement::Reader getPosition() const;

  inline double getMajorRadius() const;

  inline double getMinorRadius() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ToroidalSurface::Builder {
public:
  typedef ToroidalSurface Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPosition();
  inline  ::AxisPlacement::Builder getPosition();
  inline void setPosition( ::AxisPlacement::Reader value);
  inline  ::AxisPlacement::Builder initPosition();
  inline void adoptPosition(::capnp::Orphan< ::AxisPlacement>&& value);
  inline ::capnp::Orphan< ::AxisPlacement> disownPosition();

  inline double getMajorRadius();
  inline void setMajorRadius(double value);

  inline double getMinorRadius();
  inline void setMinorRadius(double value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ToroidalSurface::Pipeline {
public:
  typedef ToroidalSurface Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::AxisPlacement::Pipeline getPosition();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class SurfaceOfRevolution::Reader {
public:
  typedef SurfaceOfRevolution Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasBasisCurve() const;
  inline  ::ObjectRef::Reader getBasisCurve() const;

  inline bool hasAxisPosition() const;
  inline  ::AxisPlacement::Reader getAxisPosition() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class SurfaceOfRevolution::Builder {
public:
  typedef SurfaceOfRevolution Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasBasisCurve();
  inline  ::ObjectRef::Builder getBasisCurve();
  inline void setBasisCurve( ::ObjectRef::Reader value);
  inline  ::ObjectRef::Builder initBasisCurve();
  inline void adoptBasisCurve(::capnp::Orphan< ::ObjectRef>&& value);
  inline ::capnp::Orphan< ::ObjectRef> disownBasisCurve();

  inline bool hasAxisPosition();
  inline  ::AxisPlacement::Builder getAxisPosition();
  inline void setAxisPosition( ::AxisPlacement::Reader value);
  inline  ::AxisPlacement::Builder initAxisPosition();
  inline void adoptAxisPosition(::capnp::Orphan< ::AxisPlacement>&& value);
  inline ::capnp::Orphan< ::AxisPlacement> disownAxisPosition();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class SurfaceOfRevolution::Pipeline {
public:
  typedef SurfaceOfRevolution Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::ObjectRef::Pipeline getBasisCurve();
  inline  ::AxisPlacement::Pipeline getAxisPosition();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class SurfaceOfLinearExtrusion::Reader {
public:
  typedef SurfaceOfLinearExtrusion Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasBasisCurve() const;
  inline  ::ObjectRef::Reader getBasisCurve() const;

  inline bool hasDirection() const;
  inline  ::Vec3::Reader getDirection() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class SurfaceOfLinearExtrusion::Builder {
public:
  typedef SurfaceOfLinearExtrusion Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasBasisCurve();
  inline  ::ObjectRef::Builder getBasisCurve();
  inline void setBasisCurve( ::ObjectRef::Reader value);
  inline  ::ObjectRef::Builder initBasisCurve();
  inline void adoptBasisCurve(::capnp::Orphan< ::ObjectRef>&& value);
  inline ::capnp::Orphan< ::ObjectRef> disownBasisCurve();

  inline bool hasDirection();
  inline  ::Vec3::Builder getDirection();
  inline void setDirection( ::Vec3::Reader value);
  inline  ::Vec3::Builder initDirection();
  inline void adoptDirection(::capnp::Orphan< ::Vec3>&& value);
  inline ::capnp::Orphan< ::Vec3> disownDirection();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class SurfaceOfLinearExtrusion::Pipeline {
public:
  typedef SurfaceOfLinearExtrusion Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::ObjectRef::Pipeline getBasisCurve();
  inline  ::Vec3::Pipeline getDirection();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class BezierSurface::Reader {
public:
  typedef BezierSurface Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getUDegree() const;

  inline  ::uint32_t getVDegree() const;

  inline bool hasPoles() const;
  inline  ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>::Reader getPoles() const;

  inline bool hasWeights() const;
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader getWeights() const;

  inline bool getURational() const;

  inline bool getVRational() const;

  inline bool getUPeriodic() const;

  inline bool getVPeriodic() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class BezierSurface::Builder {
public:
  typedef BezierSurface Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getUDegree();
  inline void setUDegree( ::uint32_t value);

  inline  ::uint32_t getVDegree();
  inline void setVDegree( ::uint32_t value);

  inline bool hasPoles();
  inline  ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>::Builder getPoles();
  inline void setPoles( ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>::Builder initPoles(unsigned int size);
  inline void adoptPoles(::capnp::Orphan< ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>> disownPoles();

  inline bool hasWeights();
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder getWeights();
  inline void setWeights( ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setWeights(::kj::ArrayPtr<const double> value);
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder initWeights(unsigned int size);
  inline void adoptWeights(::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>> disownWeights();

  inline bool getURational();
  inline void setURational(bool value);

  inline bool getVRational();
  inline void setVRational(bool value);

  inline bool getUPeriodic();
  inline void setUPeriodic(bool value);

  inline bool getVPeriodic();
  inline void setVPeriodic(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class BezierSurface::Pipeline {
public:
  typedef BezierSurface Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class BSplineSurface::Reader {
public:
  typedef BSplineSurface Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getUDegree() const;

  inline  ::uint32_t getVDegree() const;

  inline bool hasUKnots() const;
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader getUKnots() const;

  inline bool hasVKnots() const;
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader getVKnots() const;

  inline bool hasUMultiplicities() const;
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader getUMultiplicities() const;

  inline bool hasVMultiplicities() const;
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader getVMultiplicities() const;

  inline bool hasPoles() const;
  inline  ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>::Reader getPoles() const;

  inline bool hasWeights() const;
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader getWeights() const;

  inline bool getURational() const;

  inline bool getVRational() const;

  inline bool getUPeriodic() const;

  inline bool getVPeriodic() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class BSplineSurface::Builder {
public:
  typedef BSplineSurface Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getUDegree();
  inline void setUDegree( ::uint32_t value);

  inline  ::uint32_t getVDegree();
  inline void setVDegree( ::uint32_t value);

  inline bool hasUKnots();
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder getUKnots();
  inline void setUKnots( ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setUKnots(::kj::ArrayPtr<const double> value);
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder initUKnots(unsigned int size);
  inline void adoptUKnots(::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>> disownUKnots();

  inline bool hasVKnots();
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder getVKnots();
  inline void setVKnots( ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setVKnots(::kj::ArrayPtr<const double> value);
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder initVKnots(unsigned int size);
  inline void adoptVKnots(::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>> disownVKnots();

  inline bool hasUMultiplicities();
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder getUMultiplicities();
  inline void setUMultiplicities( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setUMultiplicities(::kj::ArrayPtr<const  ::uint32_t> value);
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder initUMultiplicities(unsigned int size);
  inline void adoptUMultiplicities(::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> disownUMultiplicities();

  inline bool hasVMultiplicities();
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder getVMultiplicities();
  inline void setVMultiplicities( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setVMultiplicities(::kj::ArrayPtr<const  ::uint32_t> value);
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder initVMultiplicities(unsigned int size);
  inline void adoptVMultiplicities(::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> disownVMultiplicities();

  inline bool hasPoles();
  inline  ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>::Builder getPoles();
  inline void setPoles( ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>::Builder initPoles(unsigned int size);
  inline void adoptPoles(::capnp::Orphan< ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>> disownPoles();

  inline bool hasWeights();
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder getWeights();
  inline void setWeights( ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setWeights(::kj::ArrayPtr<const double> value);
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder initWeights(unsigned int size);
  inline void adoptWeights(::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>> disownWeights();

  inline bool getURational();
  inline void setURational(bool value);

  inline bool getVRational();
  inline void setVRational(bool value);

  inline bool getUPeriodic();
  inline void setUPeriodic(bool value);

  inline bool getVPeriodic();
  inline void setVPeriodic(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class BSplineSurface::Pipeline {
public:
  typedef BSplineSurface Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class RectangularTrimmedSurface::Reader {
public:
  typedef RectangularTrimmedSurface Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasBasisSurface() const;
  inline  ::ObjectRef::Reader getBasisSurface() const;

  inline double getUMin() const;

  inline double getUMax() const;

  inline double getVMin() const;

  inline double getVMax() const;

  inline bool getUsense() const;

  inline bool getVsense() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class RectangularTrimmedSurface::Builder {
public:
  typedef RectangularTrimmedSurface Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasBasisSurface();
  inline  ::ObjectRef::Builder getBasisSurface();
  inline void setBasisSurface( ::ObjectRef::Reader value);
  inline  ::ObjectRef::Builder initBasisSurface();
  inline void adoptBasisSurface(::capnp::Orphan< ::ObjectRef>&& value);
  inline ::capnp::Orphan< ::ObjectRef> disownBasisSurface();

  inline double getUMin();
  inline void setUMin(double value);

  inline double getUMax();
  inline void setUMax(double value);

  inline double getVMin();
  inline void setVMin(double value);

  inline double getVMax();
  inline void setVMax(double value);

  inline bool getUsense();
  inline void setUsense(bool value);

  inline bool getVsense();
  inline void setVsense(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class RectangularTrimmedSurface::Pipeline {
public:
  typedef RectangularTrimmedSurface Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::ObjectRef::Pipeline getBasisSurface();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class OffsetSurface::Reader {
public:
  typedef OffsetSurface Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasBasisSurface() const;
  inline  ::ObjectRef::Reader getBasisSurface() const;

  inline double getOffset() const;

  inline bool getOsculating() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class OffsetSurface::Builder {
public:
  typedef OffsetSurface Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasBasisSurface();
  inline  ::ObjectRef::Builder getBasisSurface();
  inline void setBasisSurface( ::ObjectRef::Reader value);
  inline  ::ObjectRef::Builder initBasisSurface();
  inline void adoptBasisSurface(::capnp::Orphan< ::ObjectRef>&& value);
  inline ::capnp::Orphan< ::ObjectRef> disownBasisSurface();

  inline double getOffset();
  inline void setOffset(double value);

  inline bool getOsculating();
  inline void setOsculating(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class OffsetSurface::Pipeline {
public:
  typedef OffsetSurface Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::ObjectRef::Pipeline getBasisSurface();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class SurfaceFile::Reader {
public:
  typedef SurfaceFile Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasSurfaces() const;
  inline  ::capnp::List< ::Surface,  ::capnp::Kind::STRUCT>::Reader getSurfaces() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class SurfaceFile::Builder {
public:
  typedef SurfaceFile Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasSurfaces();
  inline  ::capnp::List< ::Surface,  ::capnp::Kind::STRUCT>::Builder getSurfaces();
  inline void setSurfaces( ::capnp::List< ::Surface,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::Surface,  ::capnp::Kind::STRUCT>::Builder initSurfaces(unsigned int size);
  inline void adoptSurfaces(::capnp::Orphan< ::capnp::List< ::Surface,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::Surface,  ::capnp::Kind::STRUCT>> disownSurfaces();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class SurfaceFile::Pipeline {
public:
  typedef SurfaceFile Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline  ::Surface::Which Surface::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline  ::Surface::Which Surface::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Surface::Reader::getIndex() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Surface::Builder::getIndex() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Surface::Builder::setIndex( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Surface::Reader::isPlane() const {
  return which() == Surface::PLANE;
}
inline bool Surface::Builder::isPlane() {
  return which() == Surface::PLANE;
}
inline bool Surface::Reader::hasPlane() const {
  if (which() != Surface::PLANE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Surface::Builder::hasPlane() {
  if (which() != Surface::PLANE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::Plane::Reader Surface::Reader::getPlane() const {
  KJ_IREQUIRE((which() == Surface::PLANE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Plane>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::Plane::Builder Surface::Builder::getPlane() {
  KJ_IREQUIRE((which() == Surface::PLANE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Plane>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Surface::Builder::setPlane( ::Plane::Reader value) {
  _builder.setDataField<Surface::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Surface::PLANE);
  ::capnp::_::PointerHelpers< ::Plane>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::Plane::Builder Surface::Builder::initPlane() {
  _builder.setDataField<Surface::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Surface::PLANE);
  return ::capnp::_::PointerHelpers< ::Plane>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Surface::Builder::adoptPlane(
    ::capnp::Orphan< ::Plane>&& value) {
  _builder.setDataField<Surface::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Surface::PLANE);
  ::capnp::_::PointerHelpers< ::Plane>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Plane> Surface::Builder::disownPlane() {
  KJ_IREQUIRE((which() == Surface::PLANE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Plane>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Surface::Reader::isCylindricalSurface() const {
  return which() == Surface::CYLINDRICAL_SURFACE;
}
inline bool Surface::Builder::isCylindricalSurface() {
  return which() == Surface::CYLINDRICAL_SURFACE;
}
inline bool Surface::Reader::hasCylindricalSurface() const {
  if (which() != Surface::CYLINDRICAL_SURFACE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Surface::Builder::hasCylindricalSurface() {
  if (which() != Surface::CYLINDRICAL_SURFACE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::CylindricalSurface::Reader Surface::Reader::getCylindricalSurface() const {
  KJ_IREQUIRE((which() == Surface::CYLINDRICAL_SURFACE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::CylindricalSurface>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::CylindricalSurface::Builder Surface::Builder::getCylindricalSurface() {
  KJ_IREQUIRE((which() == Surface::CYLINDRICAL_SURFACE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::CylindricalSurface>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Surface::Builder::setCylindricalSurface( ::CylindricalSurface::Reader value) {
  _builder.setDataField<Surface::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Surface::CYLINDRICAL_SURFACE);
  ::capnp::_::PointerHelpers< ::CylindricalSurface>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::CylindricalSurface::Builder Surface::Builder::initCylindricalSurface() {
  _builder.setDataField<Surface::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Surface::CYLINDRICAL_SURFACE);
  return ::capnp::_::PointerHelpers< ::CylindricalSurface>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Surface::Builder::adoptCylindricalSurface(
    ::capnp::Orphan< ::CylindricalSurface>&& value) {
  _builder.setDataField<Surface::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Surface::CYLINDRICAL_SURFACE);
  ::capnp::_::PointerHelpers< ::CylindricalSurface>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::CylindricalSurface> Surface::Builder::disownCylindricalSurface() {
  KJ_IREQUIRE((which() == Surface::CYLINDRICAL_SURFACE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::CylindricalSurface>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Surface::Reader::isConicalSurface() const {
  return which() == Surface::CONICAL_SURFACE;
}
inline bool Surface::Builder::isConicalSurface() {
  return which() == Surface::CONICAL_SURFACE;
}
inline bool Surface::Reader::hasConicalSurface() const {
  if (which() != Surface::CONICAL_SURFACE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Surface::Builder::hasConicalSurface() {
  if (which() != Surface::CONICAL_SURFACE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::ConicalSurface::Reader Surface::Reader::getConicalSurface() const {
  KJ_IREQUIRE((which() == Surface::CONICAL_SURFACE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::ConicalSurface>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::ConicalSurface::Builder Surface::Builder::getConicalSurface() {
  KJ_IREQUIRE((which() == Surface::CONICAL_SURFACE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::ConicalSurface>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Surface::Builder::setConicalSurface( ::ConicalSurface::Reader value) {
  _builder.setDataField<Surface::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Surface::CONICAL_SURFACE);
  ::capnp::_::PointerHelpers< ::ConicalSurface>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::ConicalSurface::Builder Surface::Builder::initConicalSurface() {
  _builder.setDataField<Surface::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Surface::CONICAL_SURFACE);
  return ::capnp::_::PointerHelpers< ::ConicalSurface>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Surface::Builder::adoptConicalSurface(
    ::capnp::Orphan< ::ConicalSurface>&& value) {
  _builder.setDataField<Surface::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Surface::CONICAL_SURFACE);
  ::capnp::_::PointerHelpers< ::ConicalSurface>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::ConicalSurface> Surface::Builder::disownConicalSurface() {
  KJ_IREQUIRE((which() == Surface::CONICAL_SURFACE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::ConicalSurface>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Surface::Reader::isSphericalSurface() const {
  return which() == Surface::SPHERICAL_SURFACE;
}
inline bool Surface::Builder::isSphericalSurface() {
  return which() == Surface::SPHERICAL_SURFACE;
}
inline bool Surface::Reader::hasSphericalSurface() const {
  if (which() != Surface::SPHERICAL_SURFACE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Surface::Builder::hasSphericalSurface() {
  if (which() != Surface::SPHERICAL_SURFACE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::SphericalSurface::Reader Surface::Reader::getSphericalSurface() const {
  KJ_IREQUIRE((which() == Surface::SPHERICAL_SURFACE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::SphericalSurface>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::SphericalSurface::Builder Surface::Builder::getSphericalSurface() {
  KJ_IREQUIRE((which() == Surface::SPHERICAL_SURFACE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::SphericalSurface>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Surface::Builder::setSphericalSurface( ::SphericalSurface::Reader value) {
  _builder.setDataField<Surface::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Surface::SPHERICAL_SURFACE);
  ::capnp::_::PointerHelpers< ::SphericalSurface>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::SphericalSurface::Builder Surface::Builder::initSphericalSurface() {
  _builder.setDataField<Surface::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Surface::SPHERICAL_SURFACE);
  return ::capnp::_::PointerHelpers< ::SphericalSurface>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Surface::Builder::adoptSphericalSurface(
    ::capnp::Orphan< ::SphericalSurface>&& value) {
  _builder.setDataField<Surface::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Surface::SPHERICAL_SURFACE);
  ::capnp::_::PointerHelpers< ::SphericalSurface>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::SphericalSurface> Surface::Builder::disownSphericalSurface() {
  KJ_IREQUIRE((which() == Surface::SPHERICAL_SURFACE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::SphericalSurface>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Surface::Reader::isToroidalSurface() const {
  return which() == Surface::TOROIDAL_SURFACE;
}
inline bool Surface::Builder::isToroidalSurface() {
  return which() == Surface::TOROIDAL_SURFACE;
}
inline bool Surface::Reader::hasToroidalSurface() const {
  if (which() != Surface::TOROIDAL_SURFACE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Surface::Builder::hasToroidalSurface() {
  if (which() != Surface::TOROIDAL_SURFACE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::ToroidalSurface::Reader Surface::Reader::getToroidalSurface() const {
  KJ_IREQUIRE((which() == Surface::TOROIDAL_SURFACE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::ToroidalSurface>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::ToroidalSurface::Builder Surface::Builder::getToroidalSurface() {
  KJ_IREQUIRE((which() == Surface::TOROIDAL_SURFACE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::ToroidalSurface>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Surface::Builder::setToroidalSurface( ::ToroidalSurface::Reader value) {
  _builder.setDataField<Surface::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Surface::TOROIDAL_SURFACE);
  ::capnp::_::PointerHelpers< ::ToroidalSurface>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::ToroidalSurface::Builder Surface::Builder::initToroidalSurface() {
  _builder.setDataField<Surface::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Surface::TOROIDAL_SURFACE);
  return ::capnp::_::PointerHelpers< ::ToroidalSurface>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Surface::Builder::adoptToroidalSurface(
    ::capnp::Orphan< ::ToroidalSurface>&& value) {
  _builder.setDataField<Surface::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Surface::TOROIDAL_SURFACE);
  ::capnp::_::PointerHelpers< ::ToroidalSurface>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::ToroidalSurface> Surface::Builder::disownToroidalSurface() {
  KJ_IREQUIRE((which() == Surface::TOROIDAL_SURFACE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::ToroidalSurface>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Surface::Reader::isSurfaceOfRevolution() const {
  return which() == Surface::SURFACE_OF_REVOLUTION;
}
inline bool Surface::Builder::isSurfaceOfRevolution() {
  return which() == Surface::SURFACE_OF_REVOLUTION;
}
inline bool Surface::Reader::hasSurfaceOfRevolution() const {
  if (which() != Surface::SURFACE_OF_REVOLUTION) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Surface::Builder::hasSurfaceOfRevolution() {
  if (which() != Surface::SURFACE_OF_REVOLUTION) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::SurfaceOfRevolution::Reader Surface::Reader::getSurfaceOfRevolution() const {
  KJ_IREQUIRE((which() == Surface::SURFACE_OF_REVOLUTION),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::SurfaceOfRevolution>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::SurfaceOfRevolution::Builder Surface::Builder::getSurfaceOfRevolution() {
  KJ_IREQUIRE((which() == Surface::SURFACE_OF_REVOLUTION),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::SurfaceOfRevolution>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Surface::Builder::setSurfaceOfRevolution( ::SurfaceOfRevolution::Reader value) {
  _builder.setDataField<Surface::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Surface::SURFACE_OF_REVOLUTION);
  ::capnp::_::PointerHelpers< ::SurfaceOfRevolution>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::SurfaceOfRevolution::Builder Surface::Builder::initSurfaceOfRevolution() {
  _builder.setDataField<Surface::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Surface::SURFACE_OF_REVOLUTION);
  return ::capnp::_::PointerHelpers< ::SurfaceOfRevolution>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Surface::Builder::adoptSurfaceOfRevolution(
    ::capnp::Orphan< ::SurfaceOfRevolution>&& value) {
  _builder.setDataField<Surface::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Surface::SURFACE_OF_REVOLUTION);
  ::capnp::_::PointerHelpers< ::SurfaceOfRevolution>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::SurfaceOfRevolution> Surface::Builder::disownSurfaceOfRevolution() {
  KJ_IREQUIRE((which() == Surface::SURFACE_OF_REVOLUTION),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::SurfaceOfRevolution>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Surface::Reader::isSurfaceOfLinearExtrusion() const {
  return which() == Surface::SURFACE_OF_LINEAR_EXTRUSION;
}
inline bool Surface::Builder::isSurfaceOfLinearExtrusion() {
  return which() == Surface::SURFACE_OF_LINEAR_EXTRUSION;
}
inline bool Surface::Reader::hasSurfaceOfLinearExtrusion() const {
  if (which() != Surface::SURFACE_OF_LINEAR_EXTRUSION) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Surface::Builder::hasSurfaceOfLinearExtrusion() {
  if (which() != Surface::SURFACE_OF_LINEAR_EXTRUSION) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::SurfaceOfLinearExtrusion::Reader Surface::Reader::getSurfaceOfLinearExtrusion() const {
  KJ_IREQUIRE((which() == Surface::SURFACE_OF_LINEAR_EXTRUSION),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::SurfaceOfLinearExtrusion>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::SurfaceOfLinearExtrusion::Builder Surface::Builder::getSurfaceOfLinearExtrusion() {
  KJ_IREQUIRE((which() == Surface::SURFACE_OF_LINEAR_EXTRUSION),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::SurfaceOfLinearExtrusion>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Surface::Builder::setSurfaceOfLinearExtrusion( ::SurfaceOfLinearExtrusion::Reader value) {
  _builder.setDataField<Surface::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Surface::SURFACE_OF_LINEAR_EXTRUSION);
  ::capnp::_::PointerHelpers< ::SurfaceOfLinearExtrusion>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::SurfaceOfLinearExtrusion::Builder Surface::Builder::initSurfaceOfLinearExtrusion() {
  _builder.setDataField<Surface::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Surface::SURFACE_OF_LINEAR_EXTRUSION);
  return ::capnp::_::PointerHelpers< ::SurfaceOfLinearExtrusion>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Surface::Builder::adoptSurfaceOfLinearExtrusion(
    ::capnp::Orphan< ::SurfaceOfLinearExtrusion>&& value) {
  _builder.setDataField<Surface::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Surface::SURFACE_OF_LINEAR_EXTRUSION);
  ::capnp::_::PointerHelpers< ::SurfaceOfLinearExtrusion>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::SurfaceOfLinearExtrusion> Surface::Builder::disownSurfaceOfLinearExtrusion() {
  KJ_IREQUIRE((which() == Surface::SURFACE_OF_LINEAR_EXTRUSION),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::SurfaceOfLinearExtrusion>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Surface::Reader::isBezierSurface() const {
  return which() == Surface::BEZIER_SURFACE;
}
inline bool Surface::Builder::isBezierSurface() {
  return which() == Surface::BEZIER_SURFACE;
}
inline bool Surface::Reader::hasBezierSurface() const {
  if (which() != Surface::BEZIER_SURFACE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Surface::Builder::hasBezierSurface() {
  if (which() != Surface::BEZIER_SURFACE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::BezierSurface::Reader Surface::Reader::getBezierSurface() const {
  KJ_IREQUIRE((which() == Surface::BEZIER_SURFACE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::BezierSurface>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::BezierSurface::Builder Surface::Builder::getBezierSurface() {
  KJ_IREQUIRE((which() == Surface::BEZIER_SURFACE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::BezierSurface>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Surface::Builder::setBezierSurface( ::BezierSurface::Reader value) {
  _builder.setDataField<Surface::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Surface::BEZIER_SURFACE);
  ::capnp::_::PointerHelpers< ::BezierSurface>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::BezierSurface::Builder Surface::Builder::initBezierSurface() {
  _builder.setDataField<Surface::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Surface::BEZIER_SURFACE);
  return ::capnp::_::PointerHelpers< ::BezierSurface>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Surface::Builder::adoptBezierSurface(
    ::capnp::Orphan< ::BezierSurface>&& value) {
  _builder.setDataField<Surface::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Surface::BEZIER_SURFACE);
  ::capnp::_::PointerHelpers< ::BezierSurface>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::BezierSurface> Surface::Builder::disownBezierSurface() {
  KJ_IREQUIRE((which() == Surface::BEZIER_SURFACE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::BezierSurface>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Surface::Reader::isBsplineSurface() const {
  return which() == Surface::BSPLINE_SURFACE;
}
inline bool Surface::Builder::isBsplineSurface() {
  return which() == Surface::BSPLINE_SURFACE;
}
inline bool Surface::Reader::hasBsplineSurface() const {
  if (which() != Surface::BSPLINE_SURFACE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Surface::Builder::hasBsplineSurface() {
  if (which() != Surface::BSPLINE_SURFACE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::BSplineSurface::Reader Surface::Reader::getBsplineSurface() const {
  KJ_IREQUIRE((which() == Surface::BSPLINE_SURFACE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::BSplineSurface>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::BSplineSurface::Builder Surface::Builder::getBsplineSurface() {
  KJ_IREQUIRE((which() == Surface::BSPLINE_SURFACE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::BSplineSurface>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Surface::Builder::setBsplineSurface( ::BSplineSurface::Reader value) {
  _builder.setDataField<Surface::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Surface::BSPLINE_SURFACE);
  ::capnp::_::PointerHelpers< ::BSplineSurface>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::BSplineSurface::Builder Surface::Builder::initBsplineSurface() {
  _builder.setDataField<Surface::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Surface::BSPLINE_SURFACE);
  return ::capnp::_::PointerHelpers< ::BSplineSurface>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Surface::Builder::adoptBsplineSurface(
    ::capnp::Orphan< ::BSplineSurface>&& value) {
  _builder.setDataField<Surface::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Surface::BSPLINE_SURFACE);
  ::capnp::_::PointerHelpers< ::BSplineSurface>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::BSplineSurface> Surface::Builder::disownBsplineSurface() {
  KJ_IREQUIRE((which() == Surface::BSPLINE_SURFACE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::BSplineSurface>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Surface::Reader::isRectangularTrimmedSurface() const {
  return which() == Surface::RECTANGULAR_TRIMMED_SURFACE;
}
inline bool Surface::Builder::isRectangularTrimmedSurface() {
  return which() == Surface::RECTANGULAR_TRIMMED_SURFACE;
}
inline bool Surface::Reader::hasRectangularTrimmedSurface() const {
  if (which() != Surface::RECTANGULAR_TRIMMED_SURFACE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Surface::Builder::hasRectangularTrimmedSurface() {
  if (which() != Surface::RECTANGULAR_TRIMMED_SURFACE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::RectangularTrimmedSurface::Reader Surface::Reader::getRectangularTrimmedSurface() const {
  KJ_IREQUIRE((which() == Surface::RECTANGULAR_TRIMMED_SURFACE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::RectangularTrimmedSurface>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::RectangularTrimmedSurface::Builder Surface::Builder::getRectangularTrimmedSurface() {
  KJ_IREQUIRE((which() == Surface::RECTANGULAR_TRIMMED_SURFACE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::RectangularTrimmedSurface>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Surface::Builder::setRectangularTrimmedSurface( ::RectangularTrimmedSurface::Reader value) {
  _builder.setDataField<Surface::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Surface::RECTANGULAR_TRIMMED_SURFACE);
  ::capnp::_::PointerHelpers< ::RectangularTrimmedSurface>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::RectangularTrimmedSurface::Builder Surface::Builder::initRectangularTrimmedSurface() {
  _builder.setDataField<Surface::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Surface::RECTANGULAR_TRIMMED_SURFACE);
  return ::capnp::_::PointerHelpers< ::RectangularTrimmedSurface>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Surface::Builder::adoptRectangularTrimmedSurface(
    ::capnp::Orphan< ::RectangularTrimmedSurface>&& value) {
  _builder.setDataField<Surface::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Surface::RECTANGULAR_TRIMMED_SURFACE);
  ::capnp::_::PointerHelpers< ::RectangularTrimmedSurface>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::RectangularTrimmedSurface> Surface::Builder::disownRectangularTrimmedSurface() {
  KJ_IREQUIRE((which() == Surface::RECTANGULAR_TRIMMED_SURFACE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::RectangularTrimmedSurface>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Surface::Reader::isOffsetSurface() const {
  return which() == Surface::OFFSET_SURFACE;
}
inline bool Surface::Builder::isOffsetSurface() {
  return which() == Surface::OFFSET_SURFACE;
}
inline bool Surface::Reader::hasOffsetSurface() const {
  if (which() != Surface::OFFSET_SURFACE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Surface::Builder::hasOffsetSurface() {
  if (which() != Surface::OFFSET_SURFACE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::OffsetSurface::Reader Surface::Reader::getOffsetSurface() const {
  KJ_IREQUIRE((which() == Surface::OFFSET_SURFACE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::OffsetSurface>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::OffsetSurface::Builder Surface::Builder::getOffsetSurface() {
  KJ_IREQUIRE((which() == Surface::OFFSET_SURFACE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::OffsetSurface>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Surface::Builder::setOffsetSurface( ::OffsetSurface::Reader value) {
  _builder.setDataField<Surface::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Surface::OFFSET_SURFACE);
  ::capnp::_::PointerHelpers< ::OffsetSurface>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::OffsetSurface::Builder Surface::Builder::initOffsetSurface() {
  _builder.setDataField<Surface::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Surface::OFFSET_SURFACE);
  return ::capnp::_::PointerHelpers< ::OffsetSurface>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Surface::Builder::adoptOffsetSurface(
    ::capnp::Orphan< ::OffsetSurface>&& value) {
  _builder.setDataField<Surface::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Surface::OFFSET_SURFACE);
  ::capnp::_::PointerHelpers< ::OffsetSurface>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::OffsetSurface> Surface::Builder::disownOffsetSurface() {
  KJ_IREQUIRE((which() == Surface::OFFSET_SURFACE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::OffsetSurface>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Plane::Reader::hasPosition() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Plane::Builder::hasPosition() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::AxisPlacement::Reader Plane::Reader::getPosition() const {
  return ::capnp::_::PointerHelpers< ::AxisPlacement>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::AxisPlacement::Builder Plane::Builder::getPosition() {
  return ::capnp::_::PointerHelpers< ::AxisPlacement>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::AxisPlacement::Pipeline Plane::Pipeline::getPosition() {
  return  ::AxisPlacement::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Plane::Builder::setPosition( ::AxisPlacement::Reader value) {
  ::capnp::_::PointerHelpers< ::AxisPlacement>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::AxisPlacement::Builder Plane::Builder::initPosition() {
  return ::capnp::_::PointerHelpers< ::AxisPlacement>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Plane::Builder::adoptPosition(
    ::capnp::Orphan< ::AxisPlacement>&& value) {
  ::capnp::_::PointerHelpers< ::AxisPlacement>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::AxisPlacement> Plane::Builder::disownPosition() {
  return ::capnp::_::PointerHelpers< ::AxisPlacement>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool CylindricalSurface::Reader::hasPosition() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool CylindricalSurface::Builder::hasPosition() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::AxisPlacement::Reader CylindricalSurface::Reader::getPosition() const {
  return ::capnp::_::PointerHelpers< ::AxisPlacement>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::AxisPlacement::Builder CylindricalSurface::Builder::getPosition() {
  return ::capnp::_::PointerHelpers< ::AxisPlacement>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::AxisPlacement::Pipeline CylindricalSurface::Pipeline::getPosition() {
  return  ::AxisPlacement::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void CylindricalSurface::Builder::setPosition( ::AxisPlacement::Reader value) {
  ::capnp::_::PointerHelpers< ::AxisPlacement>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::AxisPlacement::Builder CylindricalSurface::Builder::initPosition() {
  return ::capnp::_::PointerHelpers< ::AxisPlacement>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void CylindricalSurface::Builder::adoptPosition(
    ::capnp::Orphan< ::AxisPlacement>&& value) {
  ::capnp::_::PointerHelpers< ::AxisPlacement>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::AxisPlacement> CylindricalSurface::Builder::disownPosition() {
  return ::capnp::_::PointerHelpers< ::AxisPlacement>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline double CylindricalSurface::Reader::getRadius() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline double CylindricalSurface::Builder::getRadius() {
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void CylindricalSurface::Builder::setRadius(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool ConicalSurface::Reader::hasPosition() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool ConicalSurface::Builder::hasPosition() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::AxisPlacement::Reader ConicalSurface::Reader::getPosition() const {
  return ::capnp::_::PointerHelpers< ::AxisPlacement>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::AxisPlacement::Builder ConicalSurface::Builder::getPosition() {
  return ::capnp::_::PointerHelpers< ::AxisPlacement>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::AxisPlacement::Pipeline ConicalSurface::Pipeline::getPosition() {
  return  ::AxisPlacement::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void ConicalSurface::Builder::setPosition( ::AxisPlacement::Reader value) {
  ::capnp::_::PointerHelpers< ::AxisPlacement>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::AxisPlacement::Builder ConicalSurface::Builder::initPosition() {
  return ::capnp::_::PointerHelpers< ::AxisPlacement>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void ConicalSurface::Builder::adoptPosition(
    ::capnp::Orphan< ::AxisPlacement>&& value) {
  ::capnp::_::PointerHelpers< ::AxisPlacement>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::AxisPlacement> ConicalSurface::Builder::disownPosition() {
  return ::capnp::_::PointerHelpers< ::AxisPlacement>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline double ConicalSurface::Reader::getRadius() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline double ConicalSurface::Builder::getRadius() {
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void ConicalSurface::Builder::setRadius(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline double ConicalSurface::Reader::getSemiAngle() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline double ConicalSurface::Builder::getSemiAngle() {
  return _builder.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void ConicalSurface::Builder::setSemiAngle(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool SphericalSurface::Reader::hasPosition() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool SphericalSurface::Builder::hasPosition() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::AxisPlacement::Reader SphericalSurface::Reader::getPosition() const {
  return ::capnp::_::PointerHelpers< ::AxisPlacement>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::AxisPlacement::Builder SphericalSurface::Builder::getPosition() {
  return ::capnp::_::PointerHelpers< ::AxisPlacement>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::AxisPlacement::Pipeline SphericalSurface::Pipeline::getPosition() {
  return  ::AxisPlacement::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void SphericalSurface::Builder::setPosition( ::AxisPlacement::Reader value) {
  ::capnp::_::PointerHelpers< ::AxisPlacement>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::AxisPlacement::Builder SphericalSurface::Builder::initPosition() {
  return ::capnp::_::PointerHelpers< ::AxisPlacement>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void SphericalSurface::Builder::adoptPosition(
    ::capnp::Orphan< ::AxisPlacement>&& value) {
  ::capnp::_::PointerHelpers< ::AxisPlacement>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::AxisPlacement> SphericalSurface::Builder::disownPosition() {
  return ::capnp::_::PointerHelpers< ::AxisPlacement>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline double SphericalSurface::Reader::getRadius() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline double SphericalSurface::Builder::getRadius() {
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void SphericalSurface::Builder::setRadius(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool ToroidalSurface::Reader::hasPosition() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool ToroidalSurface::Builder::hasPosition() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::AxisPlacement::Reader ToroidalSurface::Reader::getPosition() const {
  return ::capnp::_::PointerHelpers< ::AxisPlacement>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::AxisPlacement::Builder ToroidalSurface::Builder::getPosition() {
  return ::capnp::_::PointerHelpers< ::AxisPlacement>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::AxisPlacement::Pipeline ToroidalSurface::Pipeline::getPosition() {
  return  ::AxisPlacement::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void ToroidalSurface::Builder::setPosition( ::AxisPlacement::Reader value) {
  ::capnp::_::PointerHelpers< ::AxisPlacement>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::AxisPlacement::Builder ToroidalSurface::Builder::initPosition() {
  return ::capnp::_::PointerHelpers< ::AxisPlacement>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void ToroidalSurface::Builder::adoptPosition(
    ::capnp::Orphan< ::AxisPlacement>&& value) {
  ::capnp::_::PointerHelpers< ::AxisPlacement>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::AxisPlacement> ToroidalSurface::Builder::disownPosition() {
  return ::capnp::_::PointerHelpers< ::AxisPlacement>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline double ToroidalSurface::Reader::getMajorRadius() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline double ToroidalSurface::Builder::getMajorRadius() {
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void ToroidalSurface::Builder::setMajorRadius(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline double ToroidalSurface::Reader::getMinorRadius() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline double ToroidalSurface::Builder::getMinorRadius() {
  return _builder.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void ToroidalSurface::Builder::setMinorRadius(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool SurfaceOfRevolution::Reader::hasBasisCurve() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool SurfaceOfRevolution::Builder::hasBasisCurve() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::ObjectRef::Reader SurfaceOfRevolution::Reader::getBasisCurve() const {
  return ::capnp::_::PointerHelpers< ::ObjectRef>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::ObjectRef::Builder SurfaceOfRevolution::Builder::getBasisCurve() {
  return ::capnp::_::PointerHelpers< ::ObjectRef>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::ObjectRef::Pipeline SurfaceOfRevolution::Pipeline::getBasisCurve() {
  return  ::ObjectRef::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void SurfaceOfRevolution::Builder::setBasisCurve( ::ObjectRef::Reader value) {
  ::capnp::_::PointerHelpers< ::ObjectRef>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::ObjectRef::Builder SurfaceOfRevolution::Builder::initBasisCurve() {
  return ::capnp::_::PointerHelpers< ::ObjectRef>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void SurfaceOfRevolution::Builder::adoptBasisCurve(
    ::capnp::Orphan< ::ObjectRef>&& value) {
  ::capnp::_::PointerHelpers< ::ObjectRef>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::ObjectRef> SurfaceOfRevolution::Builder::disownBasisCurve() {
  return ::capnp::_::PointerHelpers< ::ObjectRef>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool SurfaceOfRevolution::Reader::hasAxisPosition() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool SurfaceOfRevolution::Builder::hasAxisPosition() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::AxisPlacement::Reader SurfaceOfRevolution::Reader::getAxisPosition() const {
  return ::capnp::_::PointerHelpers< ::AxisPlacement>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::AxisPlacement::Builder SurfaceOfRevolution::Builder::getAxisPosition() {
  return ::capnp::_::PointerHelpers< ::AxisPlacement>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::AxisPlacement::Pipeline SurfaceOfRevolution::Pipeline::getAxisPosition() {
  return  ::AxisPlacement::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void SurfaceOfRevolution::Builder::setAxisPosition( ::AxisPlacement::Reader value) {
  ::capnp::_::PointerHelpers< ::AxisPlacement>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::AxisPlacement::Builder SurfaceOfRevolution::Builder::initAxisPosition() {
  return ::capnp::_::PointerHelpers< ::AxisPlacement>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void SurfaceOfRevolution::Builder::adoptAxisPosition(
    ::capnp::Orphan< ::AxisPlacement>&& value) {
  ::capnp::_::PointerHelpers< ::AxisPlacement>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::AxisPlacement> SurfaceOfRevolution::Builder::disownAxisPosition() {
  return ::capnp::_::PointerHelpers< ::AxisPlacement>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool SurfaceOfLinearExtrusion::Reader::hasBasisCurve() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool SurfaceOfLinearExtrusion::Builder::hasBasisCurve() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::ObjectRef::Reader SurfaceOfLinearExtrusion::Reader::getBasisCurve() const {
  return ::capnp::_::PointerHelpers< ::ObjectRef>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::ObjectRef::Builder SurfaceOfLinearExtrusion::Builder::getBasisCurve() {
  return ::capnp::_::PointerHelpers< ::ObjectRef>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::ObjectRef::Pipeline SurfaceOfLinearExtrusion::Pipeline::getBasisCurve() {
  return  ::ObjectRef::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void SurfaceOfLinearExtrusion::Builder::setBasisCurve( ::ObjectRef::Reader value) {
  ::capnp::_::PointerHelpers< ::ObjectRef>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::ObjectRef::Builder SurfaceOfLinearExtrusion::Builder::initBasisCurve() {
  return ::capnp::_::PointerHelpers< ::ObjectRef>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void SurfaceOfLinearExtrusion::Builder::adoptBasisCurve(
    ::capnp::Orphan< ::ObjectRef>&& value) {
  ::capnp::_::PointerHelpers< ::ObjectRef>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::ObjectRef> SurfaceOfLinearExtrusion::Builder::disownBasisCurve() {
  return ::capnp::_::PointerHelpers< ::ObjectRef>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool SurfaceOfLinearExtrusion::Reader::hasDirection() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool SurfaceOfLinearExtrusion::Builder::hasDirection() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::Vec3::Reader SurfaceOfLinearExtrusion::Reader::getDirection() const {
  return ::capnp::_::PointerHelpers< ::Vec3>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::Vec3::Builder SurfaceOfLinearExtrusion::Builder::getDirection() {
  return ::capnp::_::PointerHelpers< ::Vec3>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Vec3::Pipeline SurfaceOfLinearExtrusion::Pipeline::getDirection() {
  return  ::Vec3::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void SurfaceOfLinearExtrusion::Builder::setDirection( ::Vec3::Reader value) {
  ::capnp::_::PointerHelpers< ::Vec3>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::Vec3::Builder SurfaceOfLinearExtrusion::Builder::initDirection() {
  return ::capnp::_::PointerHelpers< ::Vec3>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void SurfaceOfLinearExtrusion::Builder::adoptDirection(
    ::capnp::Orphan< ::Vec3>&& value) {
  ::capnp::_::PointerHelpers< ::Vec3>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Vec3> SurfaceOfLinearExtrusion::Builder::disownDirection() {
  return ::capnp::_::PointerHelpers< ::Vec3>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::uint32_t BezierSurface::Reader::getUDegree() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t BezierSurface::Builder::getUDegree() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void BezierSurface::Builder::setUDegree( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t BezierSurface::Reader::getVDegree() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t BezierSurface::Builder::getVDegree() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void BezierSurface::Builder::setVDegree( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool BezierSurface::Reader::hasPoles() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool BezierSurface::Builder::hasPoles() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>::Reader BezierSurface::Reader::getPoles() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>::Builder BezierSurface::Builder::getPoles() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void BezierSurface::Builder::setPoles( ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>::Builder BezierSurface::Builder::initPoles(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void BezierSurface::Builder::adoptPoles(
    ::capnp::Orphan< ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>> BezierSurface::Builder::disownPoles() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool BezierSurface::Reader::hasWeights() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool BezierSurface::Builder::hasWeights() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader BezierSurface::Reader::getWeights() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder BezierSurface::Builder::getWeights() {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void BezierSurface::Builder::setWeights( ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline void BezierSurface::Builder::setWeights(::kj::ArrayPtr<const double> value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder BezierSurface::Builder::initWeights(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void BezierSurface::Builder::adoptWeights(
    ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>> BezierSurface::Builder::disownWeights() {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool BezierSurface::Reader::getURational() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<64>() * ::capnp::ELEMENTS);
}

inline bool BezierSurface::Builder::getURational() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<64>() * ::capnp::ELEMENTS);
}
inline void BezierSurface::Builder::setURational(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<64>() * ::capnp::ELEMENTS, value);
}

inline bool BezierSurface::Reader::getVRational() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<65>() * ::capnp::ELEMENTS);
}

inline bool BezierSurface::Builder::getVRational() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<65>() * ::capnp::ELEMENTS);
}
inline void BezierSurface::Builder::setVRational(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<65>() * ::capnp::ELEMENTS, value);
}

inline bool BezierSurface::Reader::getUPeriodic() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<66>() * ::capnp::ELEMENTS);
}

inline bool BezierSurface::Builder::getUPeriodic() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<66>() * ::capnp::ELEMENTS);
}
inline void BezierSurface::Builder::setUPeriodic(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<66>() * ::capnp::ELEMENTS, value);
}

inline bool BezierSurface::Reader::getVPeriodic() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<67>() * ::capnp::ELEMENTS);
}

inline bool BezierSurface::Builder::getVPeriodic() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<67>() * ::capnp::ELEMENTS);
}
inline void BezierSurface::Builder::setVPeriodic(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<67>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t BSplineSurface::Reader::getUDegree() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t BSplineSurface::Builder::getUDegree() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void BSplineSurface::Builder::setUDegree( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t BSplineSurface::Reader::getVDegree() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t BSplineSurface::Builder::getVDegree() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void BSplineSurface::Builder::setVDegree( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool BSplineSurface::Reader::hasUKnots() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool BSplineSurface::Builder::hasUKnots() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader BSplineSurface::Reader::getUKnots() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder BSplineSurface::Builder::getUKnots() {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void BSplineSurface::Builder::setUKnots( ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void BSplineSurface::Builder::setUKnots(::kj::ArrayPtr<const double> value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder BSplineSurface::Builder::initUKnots(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void BSplineSurface::Builder::adoptUKnots(
    ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>> BSplineSurface::Builder::disownUKnots() {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool BSplineSurface::Reader::hasVKnots() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool BSplineSurface::Builder::hasVKnots() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader BSplineSurface::Reader::getVKnots() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder BSplineSurface::Builder::getVKnots() {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void BSplineSurface::Builder::setVKnots( ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline void BSplineSurface::Builder::setVKnots(::kj::ArrayPtr<const double> value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder BSplineSurface::Builder::initVKnots(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void BSplineSurface::Builder::adoptVKnots(
    ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>> BSplineSurface::Builder::disownVKnots() {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool BSplineSurface::Reader::hasUMultiplicities() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool BSplineSurface::Builder::hasUMultiplicities() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader BSplineSurface::Reader::getUMultiplicities() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder BSplineSurface::Builder::getUMultiplicities() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void BSplineSurface::Builder::setUMultiplicities( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline void BSplineSurface::Builder::setUMultiplicities(::kj::ArrayPtr<const  ::uint32_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder BSplineSurface::Builder::initUMultiplicities(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void BSplineSurface::Builder::adoptUMultiplicities(
    ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> BSplineSurface::Builder::disownUMultiplicities() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool BSplineSurface::Reader::hasVMultiplicities() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool BSplineSurface::Builder::hasVMultiplicities() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader BSplineSurface::Reader::getVMultiplicities() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder BSplineSurface::Builder::getVMultiplicities() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void BSplineSurface::Builder::setVMultiplicities( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline void BSplineSurface::Builder::setVMultiplicities(::kj::ArrayPtr<const  ::uint32_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder BSplineSurface::Builder::initVMultiplicities(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), size);
}
inline void BSplineSurface::Builder::adoptVMultiplicities(
    ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> BSplineSurface::Builder::disownVMultiplicities() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool BSplineSurface::Reader::hasPoles() const {
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline bool BSplineSurface::Builder::hasPoles() {
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>::Reader BSplineSurface::Reader::getPoles() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>::Builder BSplineSurface::Builder::getPoles() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline void BSplineSurface::Builder::setPoles( ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>::Builder BSplineSurface::Builder::initPoles(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), size);
}
inline void BSplineSurface::Builder::adoptPoles(
    ::capnp::Orphan< ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>> BSplineSurface::Builder::disownPoles() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}

inline bool BSplineSurface::Reader::hasWeights() const {
  return !_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline bool BSplineSurface::Builder::hasWeights() {
  return !_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader BSplineSurface::Reader::getWeights() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder BSplineSurface::Builder::getWeights() {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline void BSplineSurface::Builder::setWeights( ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), value);
}
inline void BSplineSurface::Builder::setWeights(::kj::ArrayPtr<const double> value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder BSplineSurface::Builder::initWeights(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), size);
}
inline void BSplineSurface::Builder::adoptWeights(
    ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>> BSplineSurface::Builder::disownWeights() {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}

inline bool BSplineSurface::Reader::getURational() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<64>() * ::capnp::ELEMENTS);
}

inline bool BSplineSurface::Builder::getURational() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<64>() * ::capnp::ELEMENTS);
}
inline void BSplineSurface::Builder::setURational(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<64>() * ::capnp::ELEMENTS, value);
}

inline bool BSplineSurface::Reader::getVRational() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<65>() * ::capnp::ELEMENTS);
}

inline bool BSplineSurface::Builder::getVRational() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<65>() * ::capnp::ELEMENTS);
}
inline void BSplineSurface::Builder::setVRational(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<65>() * ::capnp::ELEMENTS, value);
}

inline bool BSplineSurface::Reader::getUPeriodic() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<66>() * ::capnp::ELEMENTS);
}

inline bool BSplineSurface::Builder::getUPeriodic() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<66>() * ::capnp::ELEMENTS);
}
inline void BSplineSurface::Builder::setUPeriodic(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<66>() * ::capnp::ELEMENTS, value);
}

inline bool BSplineSurface::Reader::getVPeriodic() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<67>() * ::capnp::ELEMENTS);
}

inline bool BSplineSurface::Builder::getVPeriodic() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<67>() * ::capnp::ELEMENTS);
}
inline void BSplineSurface::Builder::setVPeriodic(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<67>() * ::capnp::ELEMENTS, value);
}

inline bool RectangularTrimmedSurface::Reader::hasBasisSurface() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool RectangularTrimmedSurface::Builder::hasBasisSurface() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::ObjectRef::Reader RectangularTrimmedSurface::Reader::getBasisSurface() const {
  return ::capnp::_::PointerHelpers< ::ObjectRef>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::ObjectRef::Builder RectangularTrimmedSurface::Builder::getBasisSurface() {
  return ::capnp::_::PointerHelpers< ::ObjectRef>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::ObjectRef::Pipeline RectangularTrimmedSurface::Pipeline::getBasisSurface() {
  return  ::ObjectRef::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void RectangularTrimmedSurface::Builder::setBasisSurface( ::ObjectRef::Reader value) {
  ::capnp::_::PointerHelpers< ::ObjectRef>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::ObjectRef::Builder RectangularTrimmedSurface::Builder::initBasisSurface() {
  return ::capnp::_::PointerHelpers< ::ObjectRef>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void RectangularTrimmedSurface::Builder::adoptBasisSurface(
    ::capnp::Orphan< ::ObjectRef>&& value) {
  ::capnp::_::PointerHelpers< ::ObjectRef>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::ObjectRef> RectangularTrimmedSurface::Builder::disownBasisSurface() {
  return ::capnp::_::PointerHelpers< ::ObjectRef>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline double RectangularTrimmedSurface::Reader::getUMin() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline double RectangularTrimmedSurface::Builder::getUMin() {
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void RectangularTrimmedSurface::Builder::setUMin(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline double RectangularTrimmedSurface::Reader::getUMax() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline double RectangularTrimmedSurface::Builder::getUMax() {
  return _builder.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void RectangularTrimmedSurface::Builder::setUMax(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline double RectangularTrimmedSurface::Reader::getVMin() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline double RectangularTrimmedSurface::Builder::getVMin() {
  return _builder.getDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void RectangularTrimmedSurface::Builder::setVMin(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline double RectangularTrimmedSurface::Reader::getVMax() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline double RectangularTrimmedSurface::Builder::getVMax() {
  return _builder.getDataField<double>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void RectangularTrimmedSurface::Builder::setVMax(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline bool RectangularTrimmedSurface::Reader::getUsense() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<256>() * ::capnp::ELEMENTS, true);
}

inline bool RectangularTrimmedSurface::Builder::getUsense() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<256>() * ::capnp::ELEMENTS, true);
}
inline void RectangularTrimmedSurface::Builder::setUsense(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<256>() * ::capnp::ELEMENTS, value, true);
}

inline bool RectangularTrimmedSurface::Reader::getVsense() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<257>() * ::capnp::ELEMENTS, true);
}

inline bool RectangularTrimmedSurface::Builder::getVsense() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<257>() * ::capnp::ELEMENTS, true);
}
inline void RectangularTrimmedSurface::Builder::setVsense(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<257>() * ::capnp::ELEMENTS, value, true);
}

inline bool OffsetSurface::Reader::hasBasisSurface() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool OffsetSurface::Builder::hasBasisSurface() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::ObjectRef::Reader OffsetSurface::Reader::getBasisSurface() const {
  return ::capnp::_::PointerHelpers< ::ObjectRef>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::ObjectRef::Builder OffsetSurface::Builder::getBasisSurface() {
  return ::capnp::_::PointerHelpers< ::ObjectRef>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::ObjectRef::Pipeline OffsetSurface::Pipeline::getBasisSurface() {
  return  ::ObjectRef::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void OffsetSurface::Builder::setBasisSurface( ::ObjectRef::Reader value) {
  ::capnp::_::PointerHelpers< ::ObjectRef>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::ObjectRef::Builder OffsetSurface::Builder::initBasisSurface() {
  return ::capnp::_::PointerHelpers< ::ObjectRef>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void OffsetSurface::Builder::adoptBasisSurface(
    ::capnp::Orphan< ::ObjectRef>&& value) {
  ::capnp::_::PointerHelpers< ::ObjectRef>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::ObjectRef> OffsetSurface::Builder::disownBasisSurface() {
  return ::capnp::_::PointerHelpers< ::ObjectRef>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline double OffsetSurface::Reader::getOffset() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline double OffsetSurface::Builder::getOffset() {
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void OffsetSurface::Builder::setOffset(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool OffsetSurface::Reader::getOsculating() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<64>() * ::capnp::ELEMENTS);
}

inline bool OffsetSurface::Builder::getOsculating() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<64>() * ::capnp::ELEMENTS);
}
inline void OffsetSurface::Builder::setOsculating(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<64>() * ::capnp::ELEMENTS, value);
}

inline bool SurfaceFile::Reader::hasSurfaces() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool SurfaceFile::Builder::hasSurfaces() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::Surface,  ::capnp::Kind::STRUCT>::Reader SurfaceFile::Reader::getSurfaces() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Surface,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::Surface,  ::capnp::Kind::STRUCT>::Builder SurfaceFile::Builder::getSurfaces() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Surface,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void SurfaceFile::Builder::setSurfaces( ::capnp::List< ::Surface,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Surface,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::Surface,  ::capnp::Kind::STRUCT>::Builder SurfaceFile::Builder::initSurfaces(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Surface,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void SurfaceFile::Builder::adoptSurfaces(
    ::capnp::Orphan< ::capnp::List< ::Surface,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Surface,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::Surface,  ::capnp::Kind::STRUCT>> SurfaceFile::Builder::disownSurfaces() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Surface,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}


CAPNP_END_HEADER

