// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: curves3d.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>

#ifndef CAPNP_VERSION
#error "CAPNP_VERSION is not defined, is capnp/generated-header-support.h missing?"
#elif CAPNP_VERSION != 1002000
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif

#include "ode.capnp.h"

CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(a2433f3fbfe1d1c9);
CAPNP_DECLARE_SCHEMA(935f3ac348300c4d);
CAPNP_DECLARE_SCHEMA(e0cfbe89515eed5c);
CAPNP_DECLARE_SCHEMA(c8064c5cdcd88bb8);
CAPNP_DECLARE_SCHEMA(abf9abba80b25347);
CAPNP_DECLARE_SCHEMA(821bdf581e396786);
CAPNP_DECLARE_SCHEMA(b248be2592209bd6);
CAPNP_DECLARE_SCHEMA(e730d706f6e31dd4);
CAPNP_DECLARE_SCHEMA(ba9670fe82269802);
CAPNP_DECLARE_SCHEMA(d15750dc2223b2a8);
CAPNP_DECLARE_SCHEMA(a0a37bd019595401);

}  // namespace schemas
}  // namespace capnp


struct Curve3d {
  Curve3d() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    LINE,
    CIRCLE,
    ELLIPSE,
    HYPERBOLA,
    PARABOLA,
    BEZIER_CURVE,
    BSPLINE_CURVE,
    TRIMMED_CURVE,
    OFFSET_CURVE,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a2433f3fbfe1d1c9, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Line {
  Line() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(935f3ac348300c4d, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Circle {
  Circle() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e0cfbe89515eed5c, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Ellipse {
  Ellipse() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c8064c5cdcd88bb8, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Hyperbola {
  Hyperbola() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(abf9abba80b25347, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Parabola {
  Parabola() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(821bdf581e396786, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct BezierCurve {
  BezierCurve() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b248be2592209bd6, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct BSplineCurve {
  BSplineCurve() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e730d706f6e31dd4, 1, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TrimmedCurve {
  TrimmedCurve() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ba9670fe82269802, 3, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct OffsetCurve {
  OffsetCurve() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d15750dc2223b2a8, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Curve3dFile {
  Curve3dFile() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a0a37bd019595401, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class Curve3d::Reader {
public:
  typedef Curve3d Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline  ::uint32_t getIndex() const;

  inline bool isLine() const;
  inline bool hasLine() const;
  inline  ::Line::Reader getLine() const;

  inline bool isCircle() const;
  inline bool hasCircle() const;
  inline  ::Circle::Reader getCircle() const;

  inline bool isEllipse() const;
  inline bool hasEllipse() const;
  inline  ::Ellipse::Reader getEllipse() const;

  inline bool isHyperbola() const;
  inline bool hasHyperbola() const;
  inline  ::Hyperbola::Reader getHyperbola() const;

  inline bool isParabola() const;
  inline bool hasParabola() const;
  inline  ::Parabola::Reader getParabola() const;

  inline bool isBezierCurve() const;
  inline bool hasBezierCurve() const;
  inline  ::BezierCurve::Reader getBezierCurve() const;

  inline bool isBsplineCurve() const;
  inline bool hasBsplineCurve() const;
  inline  ::BSplineCurve::Reader getBsplineCurve() const;

  inline bool isTrimmedCurve() const;
  inline bool hasTrimmedCurve() const;
  inline  ::TrimmedCurve::Reader getTrimmedCurve() const;

  inline bool isOffsetCurve() const;
  inline bool hasOffsetCurve() const;
  inline  ::OffsetCurve::Reader getOffsetCurve() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Curve3d::Builder {
public:
  typedef Curve3d Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline  ::uint32_t getIndex();
  inline void setIndex( ::uint32_t value);

  inline bool isLine();
  inline bool hasLine();
  inline  ::Line::Builder getLine();
  inline void setLine( ::Line::Reader value);
  inline  ::Line::Builder initLine();
  inline void adoptLine(::capnp::Orphan< ::Line>&& value);
  inline ::capnp::Orphan< ::Line> disownLine();

  inline bool isCircle();
  inline bool hasCircle();
  inline  ::Circle::Builder getCircle();
  inline void setCircle( ::Circle::Reader value);
  inline  ::Circle::Builder initCircle();
  inline void adoptCircle(::capnp::Orphan< ::Circle>&& value);
  inline ::capnp::Orphan< ::Circle> disownCircle();

  inline bool isEllipse();
  inline bool hasEllipse();
  inline  ::Ellipse::Builder getEllipse();
  inline void setEllipse( ::Ellipse::Reader value);
  inline  ::Ellipse::Builder initEllipse();
  inline void adoptEllipse(::capnp::Orphan< ::Ellipse>&& value);
  inline ::capnp::Orphan< ::Ellipse> disownEllipse();

  inline bool isHyperbola();
  inline bool hasHyperbola();
  inline  ::Hyperbola::Builder getHyperbola();
  inline void setHyperbola( ::Hyperbola::Reader value);
  inline  ::Hyperbola::Builder initHyperbola();
  inline void adoptHyperbola(::capnp::Orphan< ::Hyperbola>&& value);
  inline ::capnp::Orphan< ::Hyperbola> disownHyperbola();

  inline bool isParabola();
  inline bool hasParabola();
  inline  ::Parabola::Builder getParabola();
  inline void setParabola( ::Parabola::Reader value);
  inline  ::Parabola::Builder initParabola();
  inline void adoptParabola(::capnp::Orphan< ::Parabola>&& value);
  inline ::capnp::Orphan< ::Parabola> disownParabola();

  inline bool isBezierCurve();
  inline bool hasBezierCurve();
  inline  ::BezierCurve::Builder getBezierCurve();
  inline void setBezierCurve( ::BezierCurve::Reader value);
  inline  ::BezierCurve::Builder initBezierCurve();
  inline void adoptBezierCurve(::capnp::Orphan< ::BezierCurve>&& value);
  inline ::capnp::Orphan< ::BezierCurve> disownBezierCurve();

  inline bool isBsplineCurve();
  inline bool hasBsplineCurve();
  inline  ::BSplineCurve::Builder getBsplineCurve();
  inline void setBsplineCurve( ::BSplineCurve::Reader value);
  inline  ::BSplineCurve::Builder initBsplineCurve();
  inline void adoptBsplineCurve(::capnp::Orphan< ::BSplineCurve>&& value);
  inline ::capnp::Orphan< ::BSplineCurve> disownBsplineCurve();

  inline bool isTrimmedCurve();
  inline bool hasTrimmedCurve();
  inline  ::TrimmedCurve::Builder getTrimmedCurve();
  inline void setTrimmedCurve( ::TrimmedCurve::Reader value);
  inline  ::TrimmedCurve::Builder initTrimmedCurve();
  inline void adoptTrimmedCurve(::capnp::Orphan< ::TrimmedCurve>&& value);
  inline ::capnp::Orphan< ::TrimmedCurve> disownTrimmedCurve();

  inline bool isOffsetCurve();
  inline bool hasOffsetCurve();
  inline  ::OffsetCurve::Builder getOffsetCurve();
  inline void setOffsetCurve( ::OffsetCurve::Reader value);
  inline  ::OffsetCurve::Builder initOffsetCurve();
  inline void adoptOffsetCurve(::capnp::Orphan< ::OffsetCurve>&& value);
  inline ::capnp::Orphan< ::OffsetCurve> disownOffsetCurve();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Curve3d::Pipeline {
public:
  typedef Curve3d Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Line::Reader {
public:
  typedef Line Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasLocation() const;
  inline  ::Vec3::Reader getLocation() const;

  inline bool hasDirection() const;
  inline  ::Vec3::Reader getDirection() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Line::Builder {
public:
  typedef Line Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasLocation();
  inline  ::Vec3::Builder getLocation();
  inline void setLocation( ::Vec3::Reader value);
  inline  ::Vec3::Builder initLocation();
  inline void adoptLocation(::capnp::Orphan< ::Vec3>&& value);
  inline ::capnp::Orphan< ::Vec3> disownLocation();

  inline bool hasDirection();
  inline  ::Vec3::Builder getDirection();
  inline void setDirection( ::Vec3::Reader value);
  inline  ::Vec3::Builder initDirection();
  inline void adoptDirection(::capnp::Orphan< ::Vec3>&& value);
  inline ::capnp::Orphan< ::Vec3> disownDirection();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Line::Pipeline {
public:
  typedef Line Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::Vec3::Pipeline getLocation();
  inline  ::Vec3::Pipeline getDirection();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Circle::Reader {
public:
  typedef Circle Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPosition() const;
  inline  ::AxisPlacement::Reader getPosition() const;

  inline double getRadius() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Circle::Builder {
public:
  typedef Circle Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPosition();
  inline  ::AxisPlacement::Builder getPosition();
  inline void setPosition( ::AxisPlacement::Reader value);
  inline  ::AxisPlacement::Builder initPosition();
  inline void adoptPosition(::capnp::Orphan< ::AxisPlacement>&& value);
  inline ::capnp::Orphan< ::AxisPlacement> disownPosition();

  inline double getRadius();
  inline void setRadius(double value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Circle::Pipeline {
public:
  typedef Circle Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::AxisPlacement::Pipeline getPosition();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Ellipse::Reader {
public:
  typedef Ellipse Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPosition() const;
  inline  ::AxisPlacement::Reader getPosition() const;

  inline double getMajorRadius() const;

  inline double getMinorRadius() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Ellipse::Builder {
public:
  typedef Ellipse Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPosition();
  inline  ::AxisPlacement::Builder getPosition();
  inline void setPosition( ::AxisPlacement::Reader value);
  inline  ::AxisPlacement::Builder initPosition();
  inline void adoptPosition(::capnp::Orphan< ::AxisPlacement>&& value);
  inline ::capnp::Orphan< ::AxisPlacement> disownPosition();

  inline double getMajorRadius();
  inline void setMajorRadius(double value);

  inline double getMinorRadius();
  inline void setMinorRadius(double value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Ellipse::Pipeline {
public:
  typedef Ellipse Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::AxisPlacement::Pipeline getPosition();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Hyperbola::Reader {
public:
  typedef Hyperbola Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPosition() const;
  inline  ::AxisPlacement::Reader getPosition() const;

  inline double getMajorRadius() const;

  inline double getMinorRadius() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Hyperbola::Builder {
public:
  typedef Hyperbola Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPosition();
  inline  ::AxisPlacement::Builder getPosition();
  inline void setPosition( ::AxisPlacement::Reader value);
  inline  ::AxisPlacement::Builder initPosition();
  inline void adoptPosition(::capnp::Orphan< ::AxisPlacement>&& value);
  inline ::capnp::Orphan< ::AxisPlacement> disownPosition();

  inline double getMajorRadius();
  inline void setMajorRadius(double value);

  inline double getMinorRadius();
  inline void setMinorRadius(double value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Hyperbola::Pipeline {
public:
  typedef Hyperbola Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::AxisPlacement::Pipeline getPosition();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Parabola::Reader {
public:
  typedef Parabola Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPosition() const;
  inline  ::AxisPlacement::Reader getPosition() const;

  inline double getFocalLength() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Parabola::Builder {
public:
  typedef Parabola Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPosition();
  inline  ::AxisPlacement::Builder getPosition();
  inline void setPosition( ::AxisPlacement::Reader value);
  inline  ::AxisPlacement::Builder initPosition();
  inline void adoptPosition(::capnp::Orphan< ::AxisPlacement>&& value);
  inline ::capnp::Orphan< ::AxisPlacement> disownPosition();

  inline double getFocalLength();
  inline void setFocalLength(double value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Parabola::Pipeline {
public:
  typedef Parabola Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::AxisPlacement::Pipeline getPosition();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class BezierCurve::Reader {
public:
  typedef BezierCurve Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getDegree() const;

  inline bool hasPoles() const;
  inline  ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>::Reader getPoles() const;

  inline bool hasWeights() const;
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader getWeights() const;

  inline bool getRational() const;

  inline bool getPeriodic() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class BezierCurve::Builder {
public:
  typedef BezierCurve Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getDegree();
  inline void setDegree( ::uint32_t value);

  inline bool hasPoles();
  inline  ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>::Builder getPoles();
  inline void setPoles( ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>::Builder initPoles(unsigned int size);
  inline void adoptPoles(::capnp::Orphan< ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>> disownPoles();

  inline bool hasWeights();
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder getWeights();
  inline void setWeights( ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setWeights(::kj::ArrayPtr<const double> value);
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder initWeights(unsigned int size);
  inline void adoptWeights(::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>> disownWeights();

  inline bool getRational();
  inline void setRational(bool value);

  inline bool getPeriodic();
  inline void setPeriodic(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class BezierCurve::Pipeline {
public:
  typedef BezierCurve Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class BSplineCurve::Reader {
public:
  typedef BSplineCurve Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getDegree() const;

  inline bool hasKnots() const;
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader getKnots() const;

  inline bool hasMultiplicities() const;
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader getMultiplicities() const;

  inline bool hasPoles() const;
  inline  ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>::Reader getPoles() const;

  inline bool hasWeights() const;
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader getWeights() const;

  inline bool getRational() const;

  inline bool getPeriodic() const;

  inline bool getClosed() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class BSplineCurve::Builder {
public:
  typedef BSplineCurve Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getDegree();
  inline void setDegree( ::uint32_t value);

  inline bool hasKnots();
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder getKnots();
  inline void setKnots( ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setKnots(::kj::ArrayPtr<const double> value);
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder initKnots(unsigned int size);
  inline void adoptKnots(::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>> disownKnots();

  inline bool hasMultiplicities();
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder getMultiplicities();
  inline void setMultiplicities( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setMultiplicities(::kj::ArrayPtr<const  ::uint32_t> value);
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder initMultiplicities(unsigned int size);
  inline void adoptMultiplicities(::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> disownMultiplicities();

  inline bool hasPoles();
  inline  ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>::Builder getPoles();
  inline void setPoles( ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>::Builder initPoles(unsigned int size);
  inline void adoptPoles(::capnp::Orphan< ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>> disownPoles();

  inline bool hasWeights();
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder getWeights();
  inline void setWeights( ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setWeights(::kj::ArrayPtr<const double> value);
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder initWeights(unsigned int size);
  inline void adoptWeights(::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>> disownWeights();

  inline bool getRational();
  inline void setRational(bool value);

  inline bool getPeriodic();
  inline void setPeriodic(bool value);

  inline bool getClosed();
  inline void setClosed(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class BSplineCurve::Pipeline {
public:
  typedef BSplineCurve Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TrimmedCurve::Reader {
public:
  typedef TrimmedCurve Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasBasisCurve() const;
  inline  ::ObjectRef::Reader getBasisCurve() const;

  inline double getFirstParameter() const;

  inline double getLastParameter() const;

  inline bool getSense() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TrimmedCurve::Builder {
public:
  typedef TrimmedCurve Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasBasisCurve();
  inline  ::ObjectRef::Builder getBasisCurve();
  inline void setBasisCurve( ::ObjectRef::Reader value);
  inline  ::ObjectRef::Builder initBasisCurve();
  inline void adoptBasisCurve(::capnp::Orphan< ::ObjectRef>&& value);
  inline ::capnp::Orphan< ::ObjectRef> disownBasisCurve();

  inline double getFirstParameter();
  inline void setFirstParameter(double value);

  inline double getLastParameter();
  inline void setLastParameter(double value);

  inline bool getSense();
  inline void setSense(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TrimmedCurve::Pipeline {
public:
  typedef TrimmedCurve Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::ObjectRef::Pipeline getBasisCurve();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class OffsetCurve::Reader {
public:
  typedef OffsetCurve Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasBasisCurve() const;
  inline  ::ObjectRef::Reader getBasisCurve() const;

  inline double getOffset() const;

  inline bool hasDirection() const;
  inline  ::Vec3::Reader getDirection() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class OffsetCurve::Builder {
public:
  typedef OffsetCurve Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasBasisCurve();
  inline  ::ObjectRef::Builder getBasisCurve();
  inline void setBasisCurve( ::ObjectRef::Reader value);
  inline  ::ObjectRef::Builder initBasisCurve();
  inline void adoptBasisCurve(::capnp::Orphan< ::ObjectRef>&& value);
  inline ::capnp::Orphan< ::ObjectRef> disownBasisCurve();

  inline double getOffset();
  inline void setOffset(double value);

  inline bool hasDirection();
  inline  ::Vec3::Builder getDirection();
  inline void setDirection( ::Vec3::Reader value);
  inline  ::Vec3::Builder initDirection();
  inline void adoptDirection(::capnp::Orphan< ::Vec3>&& value);
  inline ::capnp::Orphan< ::Vec3> disownDirection();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class OffsetCurve::Pipeline {
public:
  typedef OffsetCurve Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::ObjectRef::Pipeline getBasisCurve();
  inline  ::Vec3::Pipeline getDirection();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Curve3dFile::Reader {
public:
  typedef Curve3dFile Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasCurves() const;
  inline  ::capnp::List< ::Curve3d,  ::capnp::Kind::STRUCT>::Reader getCurves() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Curve3dFile::Builder {
public:
  typedef Curve3dFile Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasCurves();
  inline  ::capnp::List< ::Curve3d,  ::capnp::Kind::STRUCT>::Builder getCurves();
  inline void setCurves( ::capnp::List< ::Curve3d,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::Curve3d,  ::capnp::Kind::STRUCT>::Builder initCurves(unsigned int size);
  inline void adoptCurves(::capnp::Orphan< ::capnp::List< ::Curve3d,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::Curve3d,  ::capnp::Kind::STRUCT>> disownCurves();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Curve3dFile::Pipeline {
public:
  typedef Curve3dFile Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline  ::Curve3d::Which Curve3d::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline  ::Curve3d::Which Curve3d::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Curve3d::Reader::getIndex() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Curve3d::Builder::getIndex() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Curve3d::Builder::setIndex( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Curve3d::Reader::isLine() const {
  return which() == Curve3d::LINE;
}
inline bool Curve3d::Builder::isLine() {
  return which() == Curve3d::LINE;
}
inline bool Curve3d::Reader::hasLine() const {
  if (which() != Curve3d::LINE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Curve3d::Builder::hasLine() {
  if (which() != Curve3d::LINE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::Line::Reader Curve3d::Reader::getLine() const {
  KJ_IREQUIRE((which() == Curve3d::LINE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Line>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::Line::Builder Curve3d::Builder::getLine() {
  KJ_IREQUIRE((which() == Curve3d::LINE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Line>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Curve3d::Builder::setLine( ::Line::Reader value) {
  _builder.setDataField<Curve3d::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Curve3d::LINE);
  ::capnp::_::PointerHelpers< ::Line>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::Line::Builder Curve3d::Builder::initLine() {
  _builder.setDataField<Curve3d::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Curve3d::LINE);
  return ::capnp::_::PointerHelpers< ::Line>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Curve3d::Builder::adoptLine(
    ::capnp::Orphan< ::Line>&& value) {
  _builder.setDataField<Curve3d::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Curve3d::LINE);
  ::capnp::_::PointerHelpers< ::Line>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Line> Curve3d::Builder::disownLine() {
  KJ_IREQUIRE((which() == Curve3d::LINE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Line>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Curve3d::Reader::isCircle() const {
  return which() == Curve3d::CIRCLE;
}
inline bool Curve3d::Builder::isCircle() {
  return which() == Curve3d::CIRCLE;
}
inline bool Curve3d::Reader::hasCircle() const {
  if (which() != Curve3d::CIRCLE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Curve3d::Builder::hasCircle() {
  if (which() != Curve3d::CIRCLE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::Circle::Reader Curve3d::Reader::getCircle() const {
  KJ_IREQUIRE((which() == Curve3d::CIRCLE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Circle>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::Circle::Builder Curve3d::Builder::getCircle() {
  KJ_IREQUIRE((which() == Curve3d::CIRCLE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Circle>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Curve3d::Builder::setCircle( ::Circle::Reader value) {
  _builder.setDataField<Curve3d::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Curve3d::CIRCLE);
  ::capnp::_::PointerHelpers< ::Circle>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::Circle::Builder Curve3d::Builder::initCircle() {
  _builder.setDataField<Curve3d::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Curve3d::CIRCLE);
  return ::capnp::_::PointerHelpers< ::Circle>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Curve3d::Builder::adoptCircle(
    ::capnp::Orphan< ::Circle>&& value) {
  _builder.setDataField<Curve3d::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Curve3d::CIRCLE);
  ::capnp::_::PointerHelpers< ::Circle>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Circle> Curve3d::Builder::disownCircle() {
  KJ_IREQUIRE((which() == Curve3d::CIRCLE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Circle>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Curve3d::Reader::isEllipse() const {
  return which() == Curve3d::ELLIPSE;
}
inline bool Curve3d::Builder::isEllipse() {
  return which() == Curve3d::ELLIPSE;
}
inline bool Curve3d::Reader::hasEllipse() const {
  if (which() != Curve3d::ELLIPSE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Curve3d::Builder::hasEllipse() {
  if (which() != Curve3d::ELLIPSE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::Ellipse::Reader Curve3d::Reader::getEllipse() const {
  KJ_IREQUIRE((which() == Curve3d::ELLIPSE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Ellipse>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::Ellipse::Builder Curve3d::Builder::getEllipse() {
  KJ_IREQUIRE((which() == Curve3d::ELLIPSE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Ellipse>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Curve3d::Builder::setEllipse( ::Ellipse::Reader value) {
  _builder.setDataField<Curve3d::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Curve3d::ELLIPSE);
  ::capnp::_::PointerHelpers< ::Ellipse>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::Ellipse::Builder Curve3d::Builder::initEllipse() {
  _builder.setDataField<Curve3d::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Curve3d::ELLIPSE);
  return ::capnp::_::PointerHelpers< ::Ellipse>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Curve3d::Builder::adoptEllipse(
    ::capnp::Orphan< ::Ellipse>&& value) {
  _builder.setDataField<Curve3d::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Curve3d::ELLIPSE);
  ::capnp::_::PointerHelpers< ::Ellipse>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Ellipse> Curve3d::Builder::disownEllipse() {
  KJ_IREQUIRE((which() == Curve3d::ELLIPSE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Ellipse>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Curve3d::Reader::isHyperbola() const {
  return which() == Curve3d::HYPERBOLA;
}
inline bool Curve3d::Builder::isHyperbola() {
  return which() == Curve3d::HYPERBOLA;
}
inline bool Curve3d::Reader::hasHyperbola() const {
  if (which() != Curve3d::HYPERBOLA) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Curve3d::Builder::hasHyperbola() {
  if (which() != Curve3d::HYPERBOLA) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::Hyperbola::Reader Curve3d::Reader::getHyperbola() const {
  KJ_IREQUIRE((which() == Curve3d::HYPERBOLA),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Hyperbola>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::Hyperbola::Builder Curve3d::Builder::getHyperbola() {
  KJ_IREQUIRE((which() == Curve3d::HYPERBOLA),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Hyperbola>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Curve3d::Builder::setHyperbola( ::Hyperbola::Reader value) {
  _builder.setDataField<Curve3d::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Curve3d::HYPERBOLA);
  ::capnp::_::PointerHelpers< ::Hyperbola>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::Hyperbola::Builder Curve3d::Builder::initHyperbola() {
  _builder.setDataField<Curve3d::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Curve3d::HYPERBOLA);
  return ::capnp::_::PointerHelpers< ::Hyperbola>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Curve3d::Builder::adoptHyperbola(
    ::capnp::Orphan< ::Hyperbola>&& value) {
  _builder.setDataField<Curve3d::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Curve3d::HYPERBOLA);
  ::capnp::_::PointerHelpers< ::Hyperbola>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Hyperbola> Curve3d::Builder::disownHyperbola() {
  KJ_IREQUIRE((which() == Curve3d::HYPERBOLA),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Hyperbola>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Curve3d::Reader::isParabola() const {
  return which() == Curve3d::PARABOLA;
}
inline bool Curve3d::Builder::isParabola() {
  return which() == Curve3d::PARABOLA;
}
inline bool Curve3d::Reader::hasParabola() const {
  if (which() != Curve3d::PARABOLA) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Curve3d::Builder::hasParabola() {
  if (which() != Curve3d::PARABOLA) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::Parabola::Reader Curve3d::Reader::getParabola() const {
  KJ_IREQUIRE((which() == Curve3d::PARABOLA),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Parabola>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::Parabola::Builder Curve3d::Builder::getParabola() {
  KJ_IREQUIRE((which() == Curve3d::PARABOLA),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Parabola>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Curve3d::Builder::setParabola( ::Parabola::Reader value) {
  _builder.setDataField<Curve3d::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Curve3d::PARABOLA);
  ::capnp::_::PointerHelpers< ::Parabola>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::Parabola::Builder Curve3d::Builder::initParabola() {
  _builder.setDataField<Curve3d::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Curve3d::PARABOLA);
  return ::capnp::_::PointerHelpers< ::Parabola>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Curve3d::Builder::adoptParabola(
    ::capnp::Orphan< ::Parabola>&& value) {
  _builder.setDataField<Curve3d::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Curve3d::PARABOLA);
  ::capnp::_::PointerHelpers< ::Parabola>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Parabola> Curve3d::Builder::disownParabola() {
  KJ_IREQUIRE((which() == Curve3d::PARABOLA),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Parabola>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Curve3d::Reader::isBezierCurve() const {
  return which() == Curve3d::BEZIER_CURVE;
}
inline bool Curve3d::Builder::isBezierCurve() {
  return which() == Curve3d::BEZIER_CURVE;
}
inline bool Curve3d::Reader::hasBezierCurve() const {
  if (which() != Curve3d::BEZIER_CURVE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Curve3d::Builder::hasBezierCurve() {
  if (which() != Curve3d::BEZIER_CURVE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::BezierCurve::Reader Curve3d::Reader::getBezierCurve() const {
  KJ_IREQUIRE((which() == Curve3d::BEZIER_CURVE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::BezierCurve>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::BezierCurve::Builder Curve3d::Builder::getBezierCurve() {
  KJ_IREQUIRE((which() == Curve3d::BEZIER_CURVE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::BezierCurve>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Curve3d::Builder::setBezierCurve( ::BezierCurve::Reader value) {
  _builder.setDataField<Curve3d::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Curve3d::BEZIER_CURVE);
  ::capnp::_::PointerHelpers< ::BezierCurve>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::BezierCurve::Builder Curve3d::Builder::initBezierCurve() {
  _builder.setDataField<Curve3d::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Curve3d::BEZIER_CURVE);
  return ::capnp::_::PointerHelpers< ::BezierCurve>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Curve3d::Builder::adoptBezierCurve(
    ::capnp::Orphan< ::BezierCurve>&& value) {
  _builder.setDataField<Curve3d::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Curve3d::BEZIER_CURVE);
  ::capnp::_::PointerHelpers< ::BezierCurve>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::BezierCurve> Curve3d::Builder::disownBezierCurve() {
  KJ_IREQUIRE((which() == Curve3d::BEZIER_CURVE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::BezierCurve>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Curve3d::Reader::isBsplineCurve() const {
  return which() == Curve3d::BSPLINE_CURVE;
}
inline bool Curve3d::Builder::isBsplineCurve() {
  return which() == Curve3d::BSPLINE_CURVE;
}
inline bool Curve3d::Reader::hasBsplineCurve() const {
  if (which() != Curve3d::BSPLINE_CURVE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Curve3d::Builder::hasBsplineCurve() {
  if (which() != Curve3d::BSPLINE_CURVE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::BSplineCurve::Reader Curve3d::Reader::getBsplineCurve() const {
  KJ_IREQUIRE((which() == Curve3d::BSPLINE_CURVE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::BSplineCurve>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::BSplineCurve::Builder Curve3d::Builder::getBsplineCurve() {
  KJ_IREQUIRE((which() == Curve3d::BSPLINE_CURVE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::BSplineCurve>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Curve3d::Builder::setBsplineCurve( ::BSplineCurve::Reader value) {
  _builder.setDataField<Curve3d::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Curve3d::BSPLINE_CURVE);
  ::capnp::_::PointerHelpers< ::BSplineCurve>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::BSplineCurve::Builder Curve3d::Builder::initBsplineCurve() {
  _builder.setDataField<Curve3d::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Curve3d::BSPLINE_CURVE);
  return ::capnp::_::PointerHelpers< ::BSplineCurve>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Curve3d::Builder::adoptBsplineCurve(
    ::capnp::Orphan< ::BSplineCurve>&& value) {
  _builder.setDataField<Curve3d::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Curve3d::BSPLINE_CURVE);
  ::capnp::_::PointerHelpers< ::BSplineCurve>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::BSplineCurve> Curve3d::Builder::disownBsplineCurve() {
  KJ_IREQUIRE((which() == Curve3d::BSPLINE_CURVE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::BSplineCurve>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Curve3d::Reader::isTrimmedCurve() const {
  return which() == Curve3d::TRIMMED_CURVE;
}
inline bool Curve3d::Builder::isTrimmedCurve() {
  return which() == Curve3d::TRIMMED_CURVE;
}
inline bool Curve3d::Reader::hasTrimmedCurve() const {
  if (which() != Curve3d::TRIMMED_CURVE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Curve3d::Builder::hasTrimmedCurve() {
  if (which() != Curve3d::TRIMMED_CURVE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::TrimmedCurve::Reader Curve3d::Reader::getTrimmedCurve() const {
  KJ_IREQUIRE((which() == Curve3d::TRIMMED_CURVE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::TrimmedCurve>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::TrimmedCurve::Builder Curve3d::Builder::getTrimmedCurve() {
  KJ_IREQUIRE((which() == Curve3d::TRIMMED_CURVE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::TrimmedCurve>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Curve3d::Builder::setTrimmedCurve( ::TrimmedCurve::Reader value) {
  _builder.setDataField<Curve3d::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Curve3d::TRIMMED_CURVE);
  ::capnp::_::PointerHelpers< ::TrimmedCurve>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::TrimmedCurve::Builder Curve3d::Builder::initTrimmedCurve() {
  _builder.setDataField<Curve3d::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Curve3d::TRIMMED_CURVE);
  return ::capnp::_::PointerHelpers< ::TrimmedCurve>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Curve3d::Builder::adoptTrimmedCurve(
    ::capnp::Orphan< ::TrimmedCurve>&& value) {
  _builder.setDataField<Curve3d::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Curve3d::TRIMMED_CURVE);
  ::capnp::_::PointerHelpers< ::TrimmedCurve>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::TrimmedCurve> Curve3d::Builder::disownTrimmedCurve() {
  KJ_IREQUIRE((which() == Curve3d::TRIMMED_CURVE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::TrimmedCurve>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Curve3d::Reader::isOffsetCurve() const {
  return which() == Curve3d::OFFSET_CURVE;
}
inline bool Curve3d::Builder::isOffsetCurve() {
  return which() == Curve3d::OFFSET_CURVE;
}
inline bool Curve3d::Reader::hasOffsetCurve() const {
  if (which() != Curve3d::OFFSET_CURVE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Curve3d::Builder::hasOffsetCurve() {
  if (which() != Curve3d::OFFSET_CURVE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::OffsetCurve::Reader Curve3d::Reader::getOffsetCurve() const {
  KJ_IREQUIRE((which() == Curve3d::OFFSET_CURVE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::OffsetCurve>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::OffsetCurve::Builder Curve3d::Builder::getOffsetCurve() {
  KJ_IREQUIRE((which() == Curve3d::OFFSET_CURVE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::OffsetCurve>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Curve3d::Builder::setOffsetCurve( ::OffsetCurve::Reader value) {
  _builder.setDataField<Curve3d::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Curve3d::OFFSET_CURVE);
  ::capnp::_::PointerHelpers< ::OffsetCurve>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::OffsetCurve::Builder Curve3d::Builder::initOffsetCurve() {
  _builder.setDataField<Curve3d::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Curve3d::OFFSET_CURVE);
  return ::capnp::_::PointerHelpers< ::OffsetCurve>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Curve3d::Builder::adoptOffsetCurve(
    ::capnp::Orphan< ::OffsetCurve>&& value) {
  _builder.setDataField<Curve3d::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, Curve3d::OFFSET_CURVE);
  ::capnp::_::PointerHelpers< ::OffsetCurve>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::OffsetCurve> Curve3d::Builder::disownOffsetCurve() {
  KJ_IREQUIRE((which() == Curve3d::OFFSET_CURVE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::OffsetCurve>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Line::Reader::hasLocation() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Line::Builder::hasLocation() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::Vec3::Reader Line::Reader::getLocation() const {
  return ::capnp::_::PointerHelpers< ::Vec3>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::Vec3::Builder Line::Builder::getLocation() {
  return ::capnp::_::PointerHelpers< ::Vec3>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Vec3::Pipeline Line::Pipeline::getLocation() {
  return  ::Vec3::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Line::Builder::setLocation( ::Vec3::Reader value) {
  ::capnp::_::PointerHelpers< ::Vec3>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::Vec3::Builder Line::Builder::initLocation() {
  return ::capnp::_::PointerHelpers< ::Vec3>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Line::Builder::adoptLocation(
    ::capnp::Orphan< ::Vec3>&& value) {
  ::capnp::_::PointerHelpers< ::Vec3>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Vec3> Line::Builder::disownLocation() {
  return ::capnp::_::PointerHelpers< ::Vec3>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Line::Reader::hasDirection() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Line::Builder::hasDirection() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::Vec3::Reader Line::Reader::getDirection() const {
  return ::capnp::_::PointerHelpers< ::Vec3>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::Vec3::Builder Line::Builder::getDirection() {
  return ::capnp::_::PointerHelpers< ::Vec3>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Vec3::Pipeline Line::Pipeline::getDirection() {
  return  ::Vec3::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Line::Builder::setDirection( ::Vec3::Reader value) {
  ::capnp::_::PointerHelpers< ::Vec3>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::Vec3::Builder Line::Builder::initDirection() {
  return ::capnp::_::PointerHelpers< ::Vec3>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Line::Builder::adoptDirection(
    ::capnp::Orphan< ::Vec3>&& value) {
  ::capnp::_::PointerHelpers< ::Vec3>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Vec3> Line::Builder::disownDirection() {
  return ::capnp::_::PointerHelpers< ::Vec3>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Circle::Reader::hasPosition() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Circle::Builder::hasPosition() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::AxisPlacement::Reader Circle::Reader::getPosition() const {
  return ::capnp::_::PointerHelpers< ::AxisPlacement>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::AxisPlacement::Builder Circle::Builder::getPosition() {
  return ::capnp::_::PointerHelpers< ::AxisPlacement>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::AxisPlacement::Pipeline Circle::Pipeline::getPosition() {
  return  ::AxisPlacement::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Circle::Builder::setPosition( ::AxisPlacement::Reader value) {
  ::capnp::_::PointerHelpers< ::AxisPlacement>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::AxisPlacement::Builder Circle::Builder::initPosition() {
  return ::capnp::_::PointerHelpers< ::AxisPlacement>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Circle::Builder::adoptPosition(
    ::capnp::Orphan< ::AxisPlacement>&& value) {
  ::capnp::_::PointerHelpers< ::AxisPlacement>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::AxisPlacement> Circle::Builder::disownPosition() {
  return ::capnp::_::PointerHelpers< ::AxisPlacement>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline double Circle::Reader::getRadius() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline double Circle::Builder::getRadius() {
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Circle::Builder::setRadius(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Ellipse::Reader::hasPosition() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Ellipse::Builder::hasPosition() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::AxisPlacement::Reader Ellipse::Reader::getPosition() const {
  return ::capnp::_::PointerHelpers< ::AxisPlacement>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::AxisPlacement::Builder Ellipse::Builder::getPosition() {
  return ::capnp::_::PointerHelpers< ::AxisPlacement>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::AxisPlacement::Pipeline Ellipse::Pipeline::getPosition() {
  return  ::AxisPlacement::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Ellipse::Builder::setPosition( ::AxisPlacement::Reader value) {
  ::capnp::_::PointerHelpers< ::AxisPlacement>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::AxisPlacement::Builder Ellipse::Builder::initPosition() {
  return ::capnp::_::PointerHelpers< ::AxisPlacement>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Ellipse::Builder::adoptPosition(
    ::capnp::Orphan< ::AxisPlacement>&& value) {
  ::capnp::_::PointerHelpers< ::AxisPlacement>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::AxisPlacement> Ellipse::Builder::disownPosition() {
  return ::capnp::_::PointerHelpers< ::AxisPlacement>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline double Ellipse::Reader::getMajorRadius() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline double Ellipse::Builder::getMajorRadius() {
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Ellipse::Builder::setMajorRadius(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline double Ellipse::Reader::getMinorRadius() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline double Ellipse::Builder::getMinorRadius() {
  return _builder.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Ellipse::Builder::setMinorRadius(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Hyperbola::Reader::hasPosition() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Hyperbola::Builder::hasPosition() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::AxisPlacement::Reader Hyperbola::Reader::getPosition() const {
  return ::capnp::_::PointerHelpers< ::AxisPlacement>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::AxisPlacement::Builder Hyperbola::Builder::getPosition() {
  return ::capnp::_::PointerHelpers< ::AxisPlacement>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::AxisPlacement::Pipeline Hyperbola::Pipeline::getPosition() {
  return  ::AxisPlacement::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Hyperbola::Builder::setPosition( ::AxisPlacement::Reader value) {
  ::capnp::_::PointerHelpers< ::AxisPlacement>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::AxisPlacement::Builder Hyperbola::Builder::initPosition() {
  return ::capnp::_::PointerHelpers< ::AxisPlacement>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Hyperbola::Builder::adoptPosition(
    ::capnp::Orphan< ::AxisPlacement>&& value) {
  ::capnp::_::PointerHelpers< ::AxisPlacement>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::AxisPlacement> Hyperbola::Builder::disownPosition() {
  return ::capnp::_::PointerHelpers< ::AxisPlacement>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline double Hyperbola::Reader::getMajorRadius() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline double Hyperbola::Builder::getMajorRadius() {
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Hyperbola::Builder::setMajorRadius(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline double Hyperbola::Reader::getMinorRadius() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline double Hyperbola::Builder::getMinorRadius() {
  return _builder.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Hyperbola::Builder::setMinorRadius(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Parabola::Reader::hasPosition() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Parabola::Builder::hasPosition() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::AxisPlacement::Reader Parabola::Reader::getPosition() const {
  return ::capnp::_::PointerHelpers< ::AxisPlacement>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::AxisPlacement::Builder Parabola::Builder::getPosition() {
  return ::capnp::_::PointerHelpers< ::AxisPlacement>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::AxisPlacement::Pipeline Parabola::Pipeline::getPosition() {
  return  ::AxisPlacement::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Parabola::Builder::setPosition( ::AxisPlacement::Reader value) {
  ::capnp::_::PointerHelpers< ::AxisPlacement>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::AxisPlacement::Builder Parabola::Builder::initPosition() {
  return ::capnp::_::PointerHelpers< ::AxisPlacement>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Parabola::Builder::adoptPosition(
    ::capnp::Orphan< ::AxisPlacement>&& value) {
  ::capnp::_::PointerHelpers< ::AxisPlacement>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::AxisPlacement> Parabola::Builder::disownPosition() {
  return ::capnp::_::PointerHelpers< ::AxisPlacement>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline double Parabola::Reader::getFocalLength() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline double Parabola::Builder::getFocalLength() {
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Parabola::Builder::setFocalLength(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t BezierCurve::Reader::getDegree() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t BezierCurve::Builder::getDegree() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void BezierCurve::Builder::setDegree( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool BezierCurve::Reader::hasPoles() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool BezierCurve::Builder::hasPoles() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>::Reader BezierCurve::Reader::getPoles() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>::Builder BezierCurve::Builder::getPoles() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void BezierCurve::Builder::setPoles( ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>::Builder BezierCurve::Builder::initPoles(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void BezierCurve::Builder::adoptPoles(
    ::capnp::Orphan< ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>> BezierCurve::Builder::disownPoles() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool BezierCurve::Reader::hasWeights() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool BezierCurve::Builder::hasWeights() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader BezierCurve::Reader::getWeights() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder BezierCurve::Builder::getWeights() {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void BezierCurve::Builder::setWeights( ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline void BezierCurve::Builder::setWeights(::kj::ArrayPtr<const double> value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder BezierCurve::Builder::initWeights(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void BezierCurve::Builder::adoptWeights(
    ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>> BezierCurve::Builder::disownWeights() {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool BezierCurve::Reader::getRational() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<32>() * ::capnp::ELEMENTS);
}

inline bool BezierCurve::Builder::getRational() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<32>() * ::capnp::ELEMENTS);
}
inline void BezierCurve::Builder::setRational(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<32>() * ::capnp::ELEMENTS, value);
}

inline bool BezierCurve::Reader::getPeriodic() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<33>() * ::capnp::ELEMENTS);
}

inline bool BezierCurve::Builder::getPeriodic() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<33>() * ::capnp::ELEMENTS);
}
inline void BezierCurve::Builder::setPeriodic(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<33>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t BSplineCurve::Reader::getDegree() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t BSplineCurve::Builder::getDegree() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void BSplineCurve::Builder::setDegree( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool BSplineCurve::Reader::hasKnots() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool BSplineCurve::Builder::hasKnots() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader BSplineCurve::Reader::getKnots() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder BSplineCurve::Builder::getKnots() {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void BSplineCurve::Builder::setKnots( ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void BSplineCurve::Builder::setKnots(::kj::ArrayPtr<const double> value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder BSplineCurve::Builder::initKnots(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void BSplineCurve::Builder::adoptKnots(
    ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>> BSplineCurve::Builder::disownKnots() {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool BSplineCurve::Reader::hasMultiplicities() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool BSplineCurve::Builder::hasMultiplicities() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader BSplineCurve::Reader::getMultiplicities() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder BSplineCurve::Builder::getMultiplicities() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void BSplineCurve::Builder::setMultiplicities( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline void BSplineCurve::Builder::setMultiplicities(::kj::ArrayPtr<const  ::uint32_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder BSplineCurve::Builder::initMultiplicities(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void BSplineCurve::Builder::adoptMultiplicities(
    ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> BSplineCurve::Builder::disownMultiplicities() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool BSplineCurve::Reader::hasPoles() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool BSplineCurve::Builder::hasPoles() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>::Reader BSplineCurve::Reader::getPoles() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>::Builder BSplineCurve::Builder::getPoles() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void BSplineCurve::Builder::setPoles( ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>::Builder BSplineCurve::Builder::initPoles(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void BSplineCurve::Builder::adoptPoles(
    ::capnp::Orphan< ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>> BSplineCurve::Builder::disownPoles() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Vec3,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool BSplineCurve::Reader::hasWeights() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool BSplineCurve::Builder::hasWeights() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader BSplineCurve::Reader::getWeights() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder BSplineCurve::Builder::getWeights() {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void BSplineCurve::Builder::setWeights( ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline void BSplineCurve::Builder::setWeights(::kj::ArrayPtr<const double> value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder BSplineCurve::Builder::initWeights(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), size);
}
inline void BSplineCurve::Builder::adoptWeights(
    ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>> BSplineCurve::Builder::disownWeights() {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool BSplineCurve::Reader::getRational() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<32>() * ::capnp::ELEMENTS);
}

inline bool BSplineCurve::Builder::getRational() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<32>() * ::capnp::ELEMENTS);
}
inline void BSplineCurve::Builder::setRational(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<32>() * ::capnp::ELEMENTS, value);
}

inline bool BSplineCurve::Reader::getPeriodic() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<33>() * ::capnp::ELEMENTS);
}

inline bool BSplineCurve::Builder::getPeriodic() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<33>() * ::capnp::ELEMENTS);
}
inline void BSplineCurve::Builder::setPeriodic(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<33>() * ::capnp::ELEMENTS, value);
}

inline bool BSplineCurve::Reader::getClosed() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<34>() * ::capnp::ELEMENTS);
}

inline bool BSplineCurve::Builder::getClosed() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<34>() * ::capnp::ELEMENTS);
}
inline void BSplineCurve::Builder::setClosed(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<34>() * ::capnp::ELEMENTS, value);
}

inline bool TrimmedCurve::Reader::hasBasisCurve() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TrimmedCurve::Builder::hasBasisCurve() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::ObjectRef::Reader TrimmedCurve::Reader::getBasisCurve() const {
  return ::capnp::_::PointerHelpers< ::ObjectRef>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::ObjectRef::Builder TrimmedCurve::Builder::getBasisCurve() {
  return ::capnp::_::PointerHelpers< ::ObjectRef>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::ObjectRef::Pipeline TrimmedCurve::Pipeline::getBasisCurve() {
  return  ::ObjectRef::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void TrimmedCurve::Builder::setBasisCurve( ::ObjectRef::Reader value) {
  ::capnp::_::PointerHelpers< ::ObjectRef>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::ObjectRef::Builder TrimmedCurve::Builder::initBasisCurve() {
  return ::capnp::_::PointerHelpers< ::ObjectRef>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TrimmedCurve::Builder::adoptBasisCurve(
    ::capnp::Orphan< ::ObjectRef>&& value) {
  ::capnp::_::PointerHelpers< ::ObjectRef>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::ObjectRef> TrimmedCurve::Builder::disownBasisCurve() {
  return ::capnp::_::PointerHelpers< ::ObjectRef>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline double TrimmedCurve::Reader::getFirstParameter() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline double TrimmedCurve::Builder::getFirstParameter() {
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TrimmedCurve::Builder::setFirstParameter(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline double TrimmedCurve::Reader::getLastParameter() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline double TrimmedCurve::Builder::getLastParameter() {
  return _builder.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void TrimmedCurve::Builder::setLastParameter(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool TrimmedCurve::Reader::getSense() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<128>() * ::capnp::ELEMENTS, true);
}

inline bool TrimmedCurve::Builder::getSense() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<128>() * ::capnp::ELEMENTS, true);
}
inline void TrimmedCurve::Builder::setSense(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<128>() * ::capnp::ELEMENTS, value, true);
}

inline bool OffsetCurve::Reader::hasBasisCurve() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool OffsetCurve::Builder::hasBasisCurve() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::ObjectRef::Reader OffsetCurve::Reader::getBasisCurve() const {
  return ::capnp::_::PointerHelpers< ::ObjectRef>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::ObjectRef::Builder OffsetCurve::Builder::getBasisCurve() {
  return ::capnp::_::PointerHelpers< ::ObjectRef>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::ObjectRef::Pipeline OffsetCurve::Pipeline::getBasisCurve() {
  return  ::ObjectRef::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void OffsetCurve::Builder::setBasisCurve( ::ObjectRef::Reader value) {
  ::capnp::_::PointerHelpers< ::ObjectRef>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::ObjectRef::Builder OffsetCurve::Builder::initBasisCurve() {
  return ::capnp::_::PointerHelpers< ::ObjectRef>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void OffsetCurve::Builder::adoptBasisCurve(
    ::capnp::Orphan< ::ObjectRef>&& value) {
  ::capnp::_::PointerHelpers< ::ObjectRef>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::ObjectRef> OffsetCurve::Builder::disownBasisCurve() {
  return ::capnp::_::PointerHelpers< ::ObjectRef>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline double OffsetCurve::Reader::getOffset() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline double OffsetCurve::Builder::getOffset() {
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void OffsetCurve::Builder::setOffset(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool OffsetCurve::Reader::hasDirection() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool OffsetCurve::Builder::hasDirection() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::Vec3::Reader OffsetCurve::Reader::getDirection() const {
  return ::capnp::_::PointerHelpers< ::Vec3>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::Vec3::Builder OffsetCurve::Builder::getDirection() {
  return ::capnp::_::PointerHelpers< ::Vec3>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Vec3::Pipeline OffsetCurve::Pipeline::getDirection() {
  return  ::Vec3::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void OffsetCurve::Builder::setDirection( ::Vec3::Reader value) {
  ::capnp::_::PointerHelpers< ::Vec3>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::Vec3::Builder OffsetCurve::Builder::initDirection() {
  return ::capnp::_::PointerHelpers< ::Vec3>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void OffsetCurve::Builder::adoptDirection(
    ::capnp::Orphan< ::Vec3>&& value) {
  ::capnp::_::PointerHelpers< ::Vec3>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Vec3> OffsetCurve::Builder::disownDirection() {
  return ::capnp::_::PointerHelpers< ::Vec3>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Curve3dFile::Reader::hasCurves() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Curve3dFile::Builder::hasCurves() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::Curve3d,  ::capnp::Kind::STRUCT>::Reader Curve3dFile::Reader::getCurves() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Curve3d,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::Curve3d,  ::capnp::Kind::STRUCT>::Builder Curve3dFile::Builder::getCurves() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Curve3d,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Curve3dFile::Builder::setCurves( ::capnp::List< ::Curve3d,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Curve3d,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::Curve3d,  ::capnp::Kind::STRUCT>::Builder Curve3dFile::Builder::initCurves(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Curve3d,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Curve3dFile::Builder::adoptCurves(
    ::capnp::Orphan< ::capnp::List< ::Curve3d,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Curve3d,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::Curve3d,  ::capnp::Kind::STRUCT>> Curve3dFile::Builder::disownCurves() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Curve3d,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}


CAPNP_END_HEADER

